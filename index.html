<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI文明模拟器 - 文明的兴衰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' fill='black'/%3E%3Ctext x='8' y='42' font-size='32' fill='%2322c55e' font-family='monospace'%3EAI%3C/text%3E%3C/svg%3E"/>
    <!-- Firebase SDK (compat) for realtime sync -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script>
        // Firebase Web 配置（已填入你的项目参数）
        window.__FIREBASE_CONFIG__ = window.__FIREBASE_CONFIG__ || {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };
    </script>
    
    <!-- Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#FF7D00',
                        success: '#00B42A',
                        warning: '#FF7D00',
                        danger: '#F53F3F',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .simulation-grid {
                background-size: 32px 16px;
                background-image:
                    linear-gradient(to right, rgba(0,255,0,0.25) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(0,255,0,0.25) 1px, transparent 1px);
            }
            .ascii-btn { color: #22c55e; }
            .ascii-select { color: #22c55e; background: transparent; border: 1px dashed rgba(34,197,94,0.4); padding: 2px 6px; }
            .ascii-card { border: 1px solid rgba(34,197,94,0.4); }
            /* Live HUD styles */
            @keyframes hud-blink { 0%,49%{opacity:1} 50%,100%{opacity:.25} }
            .hud-rec { animation: hud-blink 1s linear infinite; }
            .scanlines { pointer-events:none; background: repeating-linear-gradient(to bottom, rgba(34,197,94,0.08) 0 1px, transparent 1px 3px); mix-blend-mode: screen; }
            .vignette { pointer-events:none; box-shadow: inset 0 0 220px rgba(0,0,0,0.8); }
            @keyframes cam-drift { 0%{transform: translate(0,0) scale(1)} 50%{transform: translate(3px,-2px) scale(1.01)} 100%{transform: translate(0,0) scale(1)} }
            .cam-drift { animation: cam-drift 6s ease-in-out infinite; }
            @keyframes marquee {
                0% { transform: translateX(100%); }
                100% { transform: translateX(-100%); }
            }
            .marquee { white-space: nowrap; will-change: transform; animation: marquee 18s linear infinite; }
            .hud-batt { width: 56px; height: 12px; border: 1px solid rgba(34,197,94,0.6); position: relative; }
            .hud-batt::after { content: ""; position: absolute; right: -4px; top: 3px; width: 3px; height: 6px; border: 1px solid rgba(34,197,94,0.6); }
            .hud-batt-fill { height: 100%; background: linear-gradient(90deg, rgba(34,197,94,0.9), rgba(34,197,94,0.6)); }
            .sig-bar { width: 5px; background: rgba(34,197,94,0.4); }
            .sig-on { background: rgba(34,197,94,0.95); }
            .pip { position:absolute; left:10px; top:40px; width:220px; height:140px; background: rgba(0,0,0,0.55); border:1px solid rgba(34,197,94,0.4); box-shadow: 0 0 18px rgba(0,0,0,0.5); }
            .pip pre { font-size: 8px; line-height: 10px; padding:6px; color:#34d399; }
            .channel-title { position:absolute; top:8px; left:50%; transform:translateX(-50%); background: rgba(0,0,0,0.45); border:1px solid rgba(34,197,94,0.4); padding:3px 8px; font-size:12px; letter-spacing:1px; }
            /* 弹幕关闭 */
        }
    </style>
</head>
<body class="bg-black text-green-300 min-h-screen flex flex-col font-mono">
    <!-- 顶部导航栏 -->
    <header class="bg-black/90 border-b border-green-800 sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <span class="text-primary text-2xl">[CIV]</span>
                <h1 class="text-xl md:text-2xl font-bold text-gray-200">文明模拟器</h1>
            </div>
            
            <div class="hidden md:flex items-center space-x-6">
                <button id="about-btn" class="hover:text-primary transition-colors duration-200 hidden">[ 关于 ]</button>
                <button id="reset-btn" class="hover:text-primary transition-colors duration-200">[ 重置 ]</button>
            </div>
            
            <div class="flex md:hidden">
                <button id="mobile-menu-btn" class="text-gray-300 hover:text-white text-xl">[≡]</button>
            </div>
        </div>
        
        <!-- 移动端菜单 -->
        <div id="mobile-menu" class="hidden md:hidden bg-black/95 border-t border-green-800">
            <div class="container mx-auto px-4 py-2 flex flex-col space-y-3">
                <button id="mobile-about-btn" class="py-2 text-green-300 text-left hidden">[ 关于 ]</button>
                <button id="mobile-reset-btn" class="py-2 text-green-300 text-left">[ 重置 ]</button>
            </div>
        </div>
    </header>

    <!-- 主内容区 -->
    <main class="flex-grow container mx-auto px-4 py-6 md:py-10">
        <!-- 控制面板 -->
        <div class="bg-dark/50 border border-gray-800 p-4 mb-6">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                <div class="flex items-center space-x-4">
                    <button id="start-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200">[ 开始 ]</button>
                    <button id="pause-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200 hidden">[ 暂停 ]</button>
                    <button id="speed-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200">[ <span id="speed-text">1x 速度</span> ]</button>
                </div>

                <div class="flex items-center space-x-3 w-full md:w-auto">
                    <button id="ai-toggle-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-3 py-2 rounded-lg transition-all duration-200">[ <span id="ai-toggle-text">AI演化 关闭</span> ]</button>
                    <div class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2">
                        <span class="mr-2 text-gray-400">[频率]</span>
                        <select id="ai-frequency" class="bg-transparent text-sm outline-none">
                            <option value="1">每1天</option>
                            <option value="3" selected>每3天</option>
                            <option value="7">每7天</option>
                            <option value="14">每14天</option>
                        </select>
                    </div>
                    <div class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2">
                        <span class="mr-2 text-gray-400">[模式]</span>
                        <select id="mode-select" class="bg-transparent text-sm outline-none">
                            <option value="peace">和平</option>
                            <option value="normal" selected>标准</option>
                            <option value="disaster">灾变</option>
                        </select>
                    </div>
                    <label class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2 cursor-pointer select-none">[ 自动存档 ]<input id="autosave-toggle" type="checkbox" class="ml-2"></label>
                    <button id="ai-trigger-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-3 py-2 rounded-lg transition-all duration-200">[ 立即演化 ]</button>
                    <div id="ai-status" class="text-xs text-gray-400 hidden">( 计算中 ... )</div>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 w-full md:w-auto">
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌─ 模拟时间 ─┐
│ <span id="simulation-time">0年0天</span>
└──────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 人口 ──┐
│ <span id="population">0</span>
└────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ 技术水平 ┐
│ <span id="technology">0</span>
└────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 稳定性 ─┐
│ <span id="stability">0%</span>
└──────────┘</pre>
                </div>
            </div>
        </div>
        
        <!-- 文明阶段指示器 -->
        <div class="mb-6">
            <div class="flex justify-between text-xs text-gray-400 mb-1">
                <span>原始社会</span>
                <span>农业社会</span>
                <span>工业革命</span>
                <span>信息时代</span>
                <span>太空时代</span>
            </div>
            <div id="ascii-stage-bar" class="font-mono text-xs text-green-400 mt-1"></div>
        </div>
        
        <!-- 文明模拟区域 -->
        <div class="relative bg-dark/50 border border-gray-800 p-4 md:p-6 mb-6 overflow-hidden">
            <div id="simulation-area" class="simulation-grid w-full aspect-[16/9] overflow-hidden relative">
                <!-- 文明符号将在这里动态生成 -->
                <div id="civilization-symbols" class="w-full h-full"></div>
                <!-- ASCII 覆盖层（路线/区域/标签/结构） -->
                <div id="ascii-overlays" class="pointer-events-none absolute inset-0"></div>
                <!-- ASCII 画布（整帧快照） -->
                <pre id="ascii-canvas" class="absolute inset-0 m-0 p-2 text-[10px] leading-3 overflow-hidden whitespace-pre text-green-400 pointer-events-none"></pre>
                <!-- 敌方 ASCII 覆盖层（红色） -->
                <div id="ascii-overlays-enemy" class="pointer-events-none absolute inset-0"></div>
                <!-- 敌方 ASCII 画布（整帧快照，红色） -->
                <pre id="ascii-canvas-enemy" class="absolute inset-0 m-0 p-2 text-[10px] leading-3 overflow-hidden whitespace-pre text-red-400 pointer-events-none"></pre>
                <!-- 阵营提示 -->
                <div class="pointer-events-none absolute right-2 bottom-2 bg-black/40 border border-gray-700 rounded px-2 py-1 text-[11px] leading-4">
                    <div><span class="text-green-400">■</span> chat-gpt5</div>
                    <div><span class="text-red-400">■</span> claude-4.1</div>
                </div>
                <!-- Live HUD overlay -->
                <div id="live-hud" class="pointer-events-none absolute inset-0 flex flex-col justify-between select-none">
                    <div class="channel-title text-green-300">AI Civilization Live · AICAST</div>
                    <div class="flex justify-between items-start p-3 text-[12px]">
                        <div class="flex items-center gap-3">
                            <span class="hud-rec inline-block w-3.5 h-3.5 rounded-full bg-red-500"></span>
                            <span class="text-red-400 font-semibold tracking-widest">REC</span>
                            <span id="hud-viewers" class="ml-3 text-green-300">0 viewers</span>
                        </div>
                        <div class="flex items-center gap-4">
                            <span id="hud-clock" class="text-green-300 text-[14px] font-semibold">LIVE 00:00:00</span>
                            <span id="hud-cam" class="text-green-300">CAM 1</span>
                            <span id="hud-tc" class="text-green-300">TC 00:00:00:00</span>
                            <div class="flex items-center gap-2">
                                <div class="hud-batt"><div id="hud-batt-fill" class="hud-batt-fill" style="width:100%"></div></div>
                                <span id="hud-batt-pct" class="text-green-300">100%</span>
                            </div>
                            <div id="hud-signal" class="flex items-end gap-1">
                                <span id="sig1" class="sig-bar h-1.5"></span>
                                <span id="sig2" class="sig-bar h-3"></span>
                                <span id="sig3" class="sig-bar h-4.5"></span>
                                <span id="sig4" class="sig-bar h-6"></span>
                                <span id="sig5" class="sig-bar h-7.5"></span>
                            </div>
                        </div>
                    </div>
                    <div class="px-3 pb-2 relative">
                        <div class="overflow-hidden border-t border-green-800/60">
                            <div id="hud-ticker" class="marquee text-[12px] py-1.5 text-green-400"></div>
                        </div>
                    </div>
                    <div class="absolute inset-0 scanlines"></div>
                    <div class="absolute inset-0 vignette"></div>
                    <div class="pip"><pre id="pip-canvas"></pre></div>
                    <!-- 弹幕已关闭 -->
                </div>
                
                <!-- 加载覆盖层 -->
                <div id="loading-overlay" class="absolute inset-0 bg-dark/80 flex flex-col items-center justify-center z-10">
                    <div class="text-4xl text-primary mb-4 animate-spin">◌</div>
                    <p class="text-lg">文明初始化中...</p>
                </div>
            </div>
        </div>
        
        <!-- 事件日志和统计信息 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- 事件日志 -->
            <div class="lg:col-span-2 bg-dark/50 border border-gray-800 p-4">
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ 文明大事记 ]</h2>
                <div id="event-log" class="h-64 overflow-y-auto pr-2 text-sm space-y-2">
                    <p class="text-gray-400 italic">模拟开始后将显示文明发展事件...</p>
                </div>
            </div>
            
            <!-- AI 指南 + 指标与符号解释 -->
            <div class="bg-dark/50 border border-gray-800 p-4">
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ AI 指南（可选） ]</h2>
                <textarea id="guidelines-input" class="w-full bg-dark/70 border border-gray-800 rounded-lg p-3 text-sm mb-4 outline-none" rows="3" placeholder="给 AI 的演化方向提示，例如：优先绿色发展，减少战争概率……"></textarea>
                <div class="mb-4">
<pre class="bg-black/60 rounded-lg p-3 border border-green-800 text-xs leading-5 whitespace-pre-wrap">┌── AI 心情 ──┐
│ <span id="ai-mood-face">:|</span>  <span id="ai-mood-label">平稳</span>
│ <span id="ai-mood-bar">[..............] 0%</span>
└───────────┘</pre>
                </div>
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ 文明指标 ]</h2>
                <div class="grid grid-cols-2 gap-3 text-sm mb-4">
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 资源 ──┐
│ <span id="resources">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 环境 ──┐
│ <span id="environment">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 经济 ──┐
│ <span id="economy">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 文化 ──┐
│ <span id="culture">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 军力 ──┐
│ <span id="military">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 民心 ──┐
│ <span id="happiness">50</span>
└────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── 外交 ──┐
│ <span id="diplomacy">50</span>
└────────┘</pre>
                </div>
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ 符号说明 ]</h2>
                <div class="space-y-2 text-sm font-mono">
                    <div>[定居势场纹理] 聚落影响范围（密度越高字符越粗）</div>
                    <div>[技术扩散纹理] 网络/创新传播（+ 与 * 的密度）</div>
                    <div>[防御密度纹理] 要塞带（# 阶梯分布）</div>
                    <div>[治理枢纽纹理] 枢纽及通道（H 与 - 的组合）</div>
                    <div>[冲突裂痕纹理] 张力与断裂（x/X 断裂带）</div>
                    <div>[突破星云纹理] 突破溢出范围（* 星簇）</div>
                </div>
                
                <hr class="my-4 border-gray-800">
                
                <!-- 生命周期指示器 -->
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ 文明生命周期 ]</h2>
                <div class="relative pt-1">
                    <div class="flex mb-2 items-center justify-between">
                        <div>
                            <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-primary/80 bg-primary/10">
                                生命周期
                            </span>
                        </div>
                        <div class="text-right">
                            <span id="lifespan-percentage" class="text-xs font-semibold inline-block text-primary">
                                0%
                            </span>
                        </div>
                    </div>
                    <pre id="lifespan-ascii" class="font-mono text-xs text-green-400"></pre>
                </div>
                <p id="life-stage" class="text-center text-sm text-gray-400 italic">等待文明诞生...</p>
            </div>
        </div>
    </main>

    <!-- 关于模态框已禁用 -->

    <script>
        // 文明模拟器核心逻辑
        document.addEventListener('DOMContentLoaded', () => {
            // DOM元素引用
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const speedBtn = document.getElementById('speed-btn');
            const speedText = document.getElementById('speed-text');
            const resetBtn = document.getElementById('reset-btn');
            const mobileResetBtn = document.getElementById('mobile-reset-btn');
            const aboutBtn = null;
            const mobileAboutBtn = null;
            const closeAboutBtn = null;
            const startFromAboutBtn = null;
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenu = document.getElementById('mobile-menu');
            const simulationTimeEl = document.getElementById('simulation-time');
            const populationEl = document.getElementById('population');
            const technologyEl = document.getElementById('technology');
            const stabilityEl = document.getElementById('stability');
            const civilizationStageEl = document.getElementById('civilization-stage');
            const eventLogEl = document.getElementById('event-log');
            const simulationArea = document.getElementById('simulation-area');
            const civilizationSymbols = document.getElementById('civilization-symbols');
            const loadingOverlay = document.getElementById('loading-overlay');
            const lifespanProgress = document.getElementById('lifespan-progress');
            const lifespanPercentage = document.getElementById('lifespan-percentage');
            const lifeStageEl = document.getElementById('life-stage');
            const aboutModal = null;
            // 将可视层包裹以产生镜头漂移
            try {
                const area = document.getElementById('simulation-area');
                const cam = document.createElement('div');
                cam.setAttribute('id','camera-content');
                cam.setAttribute('class','absolute inset-0 cam-drift');
                // 把主要层移动到 camera-content 下
                const moveIds = ['civilization-symbols','ascii-overlays','ascii-canvas','ascii-overlays-enemy','ascii-canvas-enemy'];
                moveIds.forEach(id=>{ const el = document.getElementById(id); if(el){ cam.appendChild(el); }});
                area.insertBefore(cam, area.firstChild);
            } catch {}
            
            // 模拟状态变量
            let isRunning = false;
            let simulationSpeed = 1; // 1x, 2x, 4x, 8x
            let simulationInterval;
            let day = 0;
            let year = 0;
            let totalDays = 0;
            let aiEnabled = false;
            let aiFrequency = 3; // 天
            let aiPending = false;
            let mode = 'normal';
            let autosaveEnabled = true;
            let guidelines = '';
            
            // 文明属性
            let civilization = {
                population: 10,
                technology: 0,
                stability: 50,
                resources: 50,
                environment: 50,
                economy: 50,
                culture: 50,
                military: 50,
                happiness: 50,
                diplomacy: 50,
                settlements: [],
                events: [],
                stage: 0, // 0-4对应五个文明阶段
                lifespan: Math.floor(Math.random() * 3000) + 2000, // 文明预期寿命(天)
                isDeclining: false,
                lastEventDay: 0
            };
            // 敌方属性
            let enemy = {
                population: 8,
                technology: 0,
                stability: 50,
                resources: 50,
                environment: 50,
                economy: 50,
                culture: 50,
                military: 55,
                happiness: 45,
                diplomacy: 30,
                settlements: [],
                stage: 0,
                isDeclining: false
            };
            
            // 文明符号类型定义
            const symbolTypes = [
                { type: 'settlement', label: '●', color: 'bg-success/20 text-success', chance: 30 },       // 定居点
                { type: 'technology', label: '△', color: 'bg-primary/20 text-primary', chance: 20 },     // 技术
                { type: 'defense', label: '□', color: 'bg-secondary/20 text-secondary', chance: 15 },     // 防御
                { type: 'government', label: '◆', color: 'bg-warning/20 text-warning', chance: 15 },      // 治理
                { type: 'conflict', label: '✕', color: 'bg-danger/20 text-danger', chance: 10 },          // 冲突
                { type: 'breakthrough', label: '★', color: 'bg-purple-500/20 text-purple-400', chance: 10 } // 突破
            ];

            // Cloud Function 接口（自动选择本地或线上）
            const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const EVOLVE_ENDPOINT = isLocal
                ? 'http://localhost:5001/chat-294cc/us-central1/evolve'
                : 'https://us-central1-chat-294cc.cloudfunctions.net/evolve';

            // 敌方/本地覆盖层与画布缓存
            let localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
            let lastAIOverlays = null;
            let localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
            let lastAIEnemyOverlays = null;
            let localFieldCanvas = null;
            let localEnemyFieldCanvas = null;
            const FIELD_CANVAS_COLS = 96;
            const FIELD_CANVAS_ROWS = 48;
            const FIELD_CHARSETS = {
                settlement: [' ', '.', 'o', 'O'],
                technology: [' ', '.', '+', '*'],
                defense: [' ', '.', '+', '#'],
                government: [' ', '.', '-', 'H'],
                conflict: [' ', '.', 'x', 'X'],
                breakthrough: [' ', '.', '*', '*']
            };
            const FIELD_SIGMA = {
                settlement: 9,
                technology: 10,
                defense: 7,
                government: 9,
                conflict: 12,
                breakthrough: 9
            };
            // 持续演化视觉循环参数
            let visualPhase = 0;
            let visualLoopHandle = null;
            const VISUAL_INTERVAL_MS = 80;
            const DRIFT_AMPLITUDE = 1.5; // 单位: 百分比坐标
            let fieldCanvasEnabled = true;
            let rowCursorLocal = 0;
            let rowCursorEnemy = 0;
            const ROWS_PER_FRAME = 6;
            let rafId = null;
            let frameParity = 0;
            // 影响强度网格（用于领地判定）
            let localInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
            let enemyInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
            
            // 事件类型
            const eventTypes = [
                { 
                    type: 'positive',
                    messages: [
                        '发现了丰富的资源储备，促进了经济增长',
                        '重要的技术突破推动了文明进步',
                        '和平条约的签订带来了稳定的发展环境',
                        '农业革新大幅提高了粮食产量',
                        '杰出领袖出现，增强了社会凝聚力',
                        '新的能源来源被发现',
                        '医学进步延长了平均寿命',
                        '文化繁荣，艺术与科学齐头并进'
                    ],
                    effects: { population: 5, technology: 3, stability: 5 }
                },
                { 
                    type: 'negative',
                    messages: [
                        '自然灾害导致了重大损失',
                        '资源短缺引发社会动荡',
                        '内部冲突削弱了文明凝聚力',
                        '疾病流行导致人口减少',
                        '技术停滞不前，发展陷入瓶颈',
                        '外部威胁加剧了紧张局势',
                        '环境恶化开始影响生存条件',
                        '经济危机导致生活水平下降'
                    ],
                    effects: { population: -5, technology: -2, stability: -8 }
                },
                { 
                    type: 'neutral',
                    messages: [
                        '举行了一次重要的文化庆典',
                        '新的社会习俗开始形成',
                        '探索队发现了未知的区域',
                        '新的艺术流派开始流行',
                        '传统知识得到整理和保存',
                        '气候出现轻微变化',
                        '新的贸易路线被开辟',
                        '教育体系进行了改革'
                    ],
                    effects: { population: 1, technology: 1, stability: 0 }
                }
            ];
            
            // 文明阶段定义
            const civilizationStages = [
                { name: '原始社会', minTech: 0, maxTech: 20, color: '#00B42A' },
                { name: '农业社会', minTech: 20, maxTech: 40, color: '#722ED1' },
                { name: '工业革命', minTech: 40, maxTech: 60, color: '#FF7D00' },
                { name: '信息时代', minTech: 60, maxTech: 80, color: '#165DFF' },
                { name: '太空时代', minTech: 80, maxTech: 100, color: '#86909C' }
            ];
            
            // 生命周期阶段
            const lifeStages = [
                { name: '诞生期', range: [0, 0.1] },
                { name: '成长期', range: [0.1, 0.4] },
                { name: '繁荣期', range: [0.4, 0.7] },
                { name: '衰退期', range: [0.7, 0.9] },
                { name: '末期', range: [0.9, 1.0] }
            ];
            
            // 初始化
            function initialize() {
                // 重置文明状态
                civilization = {
                    population: 10,
                    technology: 0,
                    stability: 50,
                    resources: 50,
                    environment: 50,
                    economy: 50,
                    culture: 50,
                    military: 50,
                    happiness: 50,
                    diplomacy: 50,
                    settlements: [],
                    events: [],
                    stage: 0,
                    lifespan: Math.floor(Math.random() * 3000) + 2000, // 5-15年左右
                    isDeclining: false,
                    lastEventDay: 0
                };
                
                // 重置时间
                day = 0;
                year = 0;
                totalDays = 0;
                
                // 清空符号和事件
                civilizationSymbols.innerHTML = '';
                eventLogEl.innerHTML = '<p class="text-gray-400 italic">模拟开始后将显示文明发展事件...</p>';
                // 清空抽象覆盖层
                localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                lastAIOverlays = null;
                localFieldCanvas = null;
                // 敌方初始化
                enemy = {
                    population: 8,
                    technology: 0,
                    stability: 50,
                    resources: 50,
                    environment: 50,
                    economy: 50,
                    culture: 50,
                    military: 55,
                    happiness: 45,
                    diplomacy: 30,
                    settlements: [],
                    stage: 0,
                    isDeclining: false
                };
                localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                lastAIEnemyOverlays = null;
                localEnemyFieldCanvas = null;
                renderMergedOverlays(null);
                renderMergedEnemyOverlays(null);
                const asciiCanvas = document.getElementById('ascii-canvas');
                if (asciiCanvas) asciiCanvas.textContent = '';
                const asciiCanvasEnemy = document.getElementById('ascii-canvas-enemy');
                if (asciiCanvasEnemy) asciiCanvasEnemy.textContent = '';
                // 重置并启动视觉循环
                stopVisualLoop();
                startVisualLoop();
                
                // 更新UI
                updateUI();
                
                // 显示加载状态
                loadingOverlay.classList.remove('hidden');
                
                // 模拟初始化过程
                setTimeout(() => {
                    // 创建初始定居点
                    addSymbol('settlement', 50, 50);
                    addEnemySymbol('settlement', 72, 52);
                    addEvent('neutral', '文明在这片土地上诞生了');
                    
                    // 隐藏加载状态
                    loadingOverlay.classList.add('hidden');
                }, 1500);
            }
            
            // 更新UI显示
            function updateUI() {
                // 更新时间显示
                simulationTimeEl.textContent = `${year}年${day}天`;
                
                // 更新文明属性
                populationEl.textContent = formatNumber(civilization.population);
                technologyEl.textContent = Math.round(civilization.technology);
                stabilityEl.textContent = `${Math.round(civilization.stability)}%`;
                document.getElementById('resources').textContent = Math.round(civilization.resources);
                document.getElementById('environment').textContent = Math.round(civilization.environment);
                document.getElementById('economy').textContent = Math.round(civilization.economy);
                document.getElementById('culture').textContent = Math.round(civilization.culture);
                document.getElementById('military').textContent = Math.round(civilization.military);
                document.getElementById('happiness').textContent = Math.round(civilization.happiness);
                document.getElementById('diplomacy').textContent = Math.round(civilization.diplomacy);
                
                // 更新文明阶段
                updateCivilizationStage();
                updateAsciiStageBar();
                
                // 更新生命周期
                updateLifespanProgress();
                // 更新 HUD
                updateLiveHUD();
            }

            // 添加不影响数值的叙事事件
            function addNarrativeEvent(eventType, message) {
                const eventEl = document.createElement('pre');
                eventEl.className = 'font-mono text-xs p-2 rounded-lg bg-gray-800/60 text-gray-300 whitespace-pre-wrap';
                const prefix = eventType === 'positive' ? '[+]' : eventType === 'negative' ? '[-]' : '[*]';
                eventEl.textContent = `${prefix} ${year}年${day}天 | ${message}`;
                if (eventLogEl.firstChild) {
                    eventLogEl.insertBefore(eventEl, eventLogEl.firstChild);
                } else {
                    eventLogEl.appendChild(eventEl);
                }
                eventLogEl.scrollTop = 0;
                civilization.events.push({ day: totalDays, type: eventType, message });
                civilization.lastEventDay = totalDays;
            }

            function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

            function applyAIDelta(result) {
                if (!result || !result.stateDelta) return;
                const d = result.stateDelta;
                if (typeof d.populationDelta === 'number') {
                    civilization.population = Math.max(1, civilization.population + d.populationDelta);
                }
                if (typeof d.technologyDelta === 'number') {
                    civilization.technology = clamp(civilization.technology + d.technologyDelta, 0, 100);
                }
                if (typeof d.stabilityDelta === 'number') {
                    civilization.stability = clamp(civilization.stability + d.stabilityDelta, 0, 100);
                }
                if (typeof d.resourcesDelta === 'number') {
                    civilization.resources = clamp(civilization.resources + d.resourcesDelta, 0, 100);
                }
                if (typeof d.environmentDelta === 'number') {
                    civilization.environment = clamp(civilization.environment + d.environmentDelta, 0, 100);
                }
                if (typeof d.economyDelta === 'number') {
                    civilization.economy = clamp(civilization.economy + d.economyDelta, 0, 100);
                }
                if (typeof d.cultureDelta === 'number') {
                    civilization.culture = clamp(civilization.culture + d.cultureDelta, 0, 100);
                }
                if (typeof d.militaryDelta === 'number') {
                    civilization.military = clamp(civilization.military + d.militaryDelta, 0, 100);
                }
                if (typeof d.happinessDelta === 'number') {
                    civilization.happiness = clamp(civilization.happiness + d.happinessDelta, 0, 100);
                }
                if (typeof d.diplomacyDelta === 'number') {
                    civilization.diplomacy = clamp(civilization.diplomacy + d.diplomacyDelta, 0, 100);
                }
                if (typeof d.isDeclining === 'boolean') {
                    civilization.isDeclining = d.isDeclining;
                }
                if (Array.isArray(result.symbols)) {
                    result.symbols.slice(0, 3).forEach(s => {
                        if (!s || !s.type || typeof s.x !== 'number' || typeof s.y !== 'number') return;
                        const t = ['settlement','technology','defense','government','conflict','breakthrough'].includes(s.type) ? s.type : 'settlement';
                        const x = clamp(s.x, 10, 90);
                        const y = clamp(s.y, 10, 90);
                        addSymbol(t, x, y, !!s.isLarge);
                    });
                }
                // 敌方增量与符号
                if (result.enemyDelta) {
                    const d2 = result.enemyDelta;
                    if (typeof d2.populationDelta === 'number') enemy.population = Math.max(1, enemy.population + d2.populationDelta);
                    if (typeof d2.technologyDelta === 'number') enemy.technology = clamp(enemy.technology + d2.technologyDelta, 0, 100);
                    if (typeof d2.stabilityDelta === 'number') enemy.stability = clamp(enemy.stability + d2.stabilityDelta, 0, 100);
                    if (typeof d2.resourcesDelta === 'number') enemy.resources = clamp(enemy.resources + d2.resourcesDelta, 0, 100);
                    if (typeof d2.environmentDelta === 'number') enemy.environment = clamp(enemy.environment + d2.environmentDelta, 0, 100);
                    if (typeof d2.economyDelta === 'number') enemy.economy = clamp(enemy.economy + d2.economyDelta, 0, 100);
                    if (typeof d2.cultureDelta === 'number') enemy.culture = clamp(enemy.culture + d2.cultureDelta, 0, 100);
                    if (typeof d2.militaryDelta === 'number') enemy.military = clamp(enemy.military + d2.militaryDelta, 0, 100);
                    if (typeof d2.happinessDelta === 'number') enemy.happiness = clamp(enemy.happiness + d2.happinessDelta, 0, 100);
                    if (typeof d2.diplomacyDelta === 'number') enemy.diplomacy = clamp(enemy.diplomacy + d2.diplomacyDelta, 0, 100);
                    if (typeof d2.isDeclining === 'boolean') enemy.isDeclining = d2.isDeclining;
                }
                if (Array.isArray(result.enemySymbols)) {
                    result.enemySymbols.slice(0, 3).forEach(s => {
                        if (!s || !s.type || typeof s.x !== 'number' || typeof s.y !== 'number') return;
                        const t = ['settlement','technology','defense','government','conflict','breakthrough'].includes(s.type) ? s.type : 'settlement';
                        const x = clamp(s.x, 10, 90);
                        const y = clamp(s.y, 10, 90);
                        addEnemySymbol(t, x, y, !!s.isLarge);
                    });
                }
                if (Array.isArray(result.events)) {
                    result.events.slice(0, 4).forEach(ev => {
                        const t = ev?.type === 'positive' || ev?.type === 'negative' ? ev.type : 'neutral';
                        addNarrativeEvent(t, ev?.message || 'AI生成的事件');
                    });
                }
                if (result.battle && result.battle.summary) {
                    addNarrativeEvent('neutral', `战报: ${result.battle.summary}`);
                }
                // 计算 AI 心情（基于正负事件占比与稳定性）
                try {
                    const recent = (result.events || []).slice(0, 4);
                    const positive = recent.filter(e => e?.type === 'positive').length;
                    const negative = recent.filter(e => e?.type === 'negative').length;
                    const moodScore = clamp(50 + (positive - negative) * 10 + (civilization.stability - 50) * 0.2, 0, 100);
                    updateAIMood(moodScore);
                } catch {}

                // 绘制 ASCII 覆盖层
                try {
                    if (result.overlays) { lastAIOverlays = result.overlays; }
                    renderMergedOverlays(lastAIOverlays);
                } catch {}
                // 敌方覆盖层
                try {
                    if (result.enemyOverlays) { lastAIEnemyOverlays = result.enemyOverlays; }
                    renderMergedEnemyOverlays(lastAIEnemyOverlays);
                } catch {}
                // 渲染整帧 ASCII 画布
                try {
                    renderAsciiCanvasMerged();
                    renderEnemyAsciiCanvasMerged();
                } catch {}
            }

            function percentToPxX(p) { return (p / 100) * simulationArea.clientWidth; }
            function percentToPxY(p) { return (p / 100) * simulationArea.clientHeight; }

            function renderAsciiOverlays(overlays) {
                const layer = document.getElementById('ascii-overlays');
                if (!layer) return;
                layer.innerHTML = '';
                const ns = 'http://www.w3.org/2000/svg';
                // 用 SVG 便于画线，但只渲染 ASCII 字符
                const svg = document.createElementNS(ns, 'svg');
                svg.setAttribute('class', 'absolute inset-0 w-full h-full');
                svg.setAttribute('viewBox', `0 0 ${simulationArea.clientWidth} ${simulationArea.clientHeight}`);

                // routes: 用小文字连续铺设字符
                (overlays.routes || []).slice(0, 3).forEach(r => {
                    const [x1,y1] = r.from || [10,10];
                    const [x2,y2] = r.to || [90,90];
                    const ch = r.char || '-';
                    const steps = 18;
                    for (let i=0;i<=steps;i++) {
                        const t = i/steps;
                        const x = percentToPxX(x1 + (x2 - x1)*t);
                        const y = percentToPxY(y1 + (y2 - y1)*t);
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y);
                        text.setAttribute('fill', '#15803d');
                        text.setAttribute('font-size', '9');
                        text.textContent = ch;
                        svg.appendChild(text);
                    }
                });

                // regions: 圆环点阵
                (overlays.regions || []).slice(0, 4).forEach(g => {
                    const [cx,cy] = g.center || [50,50];
                    const r = Math.max(5, Math.min(16, g.radius || 8));
                    const ch = g.char || '*';
                    const dots = r * 7;
                    for (let i=0;i<dots;i++) {
                        const a = (i/dots) * 2*Math.PI;
                        const x = percentToPxX(cx + Math.cos(a)*r);
                        const y = percentToPxY(cy + Math.sin(a)*r);
                        const t = document.createElementNS(ns, 'text');
                        t.setAttribute('x', x);
                        t.setAttribute('y', y);
                        t.setAttribute('fill', '#15803d');
                        t.setAttribute('font-size', '9');
                        t.textContent = ch;
                        svg.appendChild(t);
                    }
                });

                // labels
                (overlays.labels || []).slice(0, 3).forEach(l => {
                    const [lx,ly] = l.at || [50,50];
                    const t = document.createElementNS(ns, 'text');
                    t.setAttribute('x', percentToPxX(lx));
                    t.setAttribute('y', percentToPxY(ly));
                    t.setAttribute('fill', '#16a34a');
                    t.setAttribute('font-size', '10');
                    t.textContent = `[${l.text || 'LABEL'}]`;
                    svg.appendChild(t);
                });

                // structures: 简单字符方阵
                (overlays.structures || []).slice(0, 2).forEach(s => {
                    const [sx,sy] = s.at || [50,50];
                    const size = Math.max(3, Math.min(6, s.size || 4));
                    for (let i=0;i<size;i++) {
                        for (let j=0;j<size;j++) {
                            const t = document.createElementNS(ns, 'text');
                            t.setAttribute('x', percentToPxX(sx + i*0.6));
                            t.setAttribute('y', percentToPxY(sy + j*0.6));
                            t.setAttribute('fill', '#15803d');
                            t.setAttribute('font-size', '9');
                            t.textContent = s.shape === 'fort' ? '#' : s.shape === 'hub' ? '+' : '█';
                            svg.appendChild(t);
                        }
                    }
                });

                layer.appendChild(svg);
            }

            // 敌方覆盖层（红色）
            function renderAsciiOverlaysEnemy(overlays) {
                const layer = document.getElementById('ascii-overlays-enemy');
                if (!layer) return;
                layer.innerHTML = '';
                const ns = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(ns, 'svg');
                svg.setAttribute('class', 'absolute inset-0 w-full h-full');
                svg.setAttribute('viewBox', `0 0 ${simulationArea.clientWidth} ${simulationArea.clientHeight}`);
                (overlays.routes || []).slice(0, 3).forEach(r => {
                    const [x1,y1] = r.from || [10,10];
                    const [x2,y2] = r.to || [90,90];
                    const ch = r.char || '-';
                    const steps = 18;
                    for (let i=0;i<=steps;i++) {
                        const t = i/steps;
                        const x = percentToPxX(x1 + (x2 - x1)*t);
                        const y = percentToPxY(y1 + (y2 - y1)*t);
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y);
                        text.setAttribute('fill', '#dc2626');
                        text.setAttribute('font-size', '9');
                        text.textContent = ch;
                        svg.appendChild(text);
                    }
                });
                (overlays.regions || []).slice(0, 4).forEach(g => {
                    const [cx,cy] = g.center || [50,50];
                    const r = Math.max(5, Math.min(16, g.radius || 8));
                    const ch = g.char || 'x';
                    const dots = r * 7;
                    for (let i=0;i<dots;i++) {
                        const a = (i/dots) * 2*Math.PI;
                        const x = percentToPxX(cx + Math.cos(a)*r);
                        const y = percentToPxY(cy + Math.sin(a)*r);
                        const t = document.createElementNS(ns, 'text');
                        t.setAttribute('x', x);
                        t.setAttribute('y', y);
                        t.setAttribute('fill', '#ef4444');
                        t.setAttribute('font-size', '9');
                        t.textContent = ch;
                        svg.appendChild(t);
                    }
                });
                (overlays.labels || []).slice(0, 3).forEach(l => {
                    const [lx,ly] = l.at || [50,50];
                    const t = document.createElementNS(ns, 'text');
                    t.setAttribute('x', percentToPxX(lx));
                    t.setAttribute('y', percentToPxY(ly));
                    t.setAttribute('fill', '#ef4444');
                    t.setAttribute('font-size', '10');
                    t.textContent = `[${l.text || 'ENEMY'}]`;
                    svg.appendChild(t);
                });
                (overlays.structures || []).slice(0, 2).forEach(s => {
                    const [sx,sy] = s.at || [50,50];
                    const size = Math.max(3, Math.min(6, s.size || 4));
                    for (let i=0;i<size;i++) {
                        for (let j=0;j<size;j++) {
                            const t = document.createElementNS(ns, 'text');
                            t.setAttribute('x', percentToPxX(sx + i*0.6));
                            t.setAttribute('y', percentToPxY(sy + j*0.6));
                            t.setAttribute('fill', '#dc2626');
                            t.setAttribute('font-size', '9');
                            t.textContent = s.shape === 'fort' ? '#' : s.shape === 'hub' ? '+' : '█';
                            svg.appendChild(t);
                        }
                    }
                });
                layer.appendChild(svg);
            }

            // 合并并渲染 AI 覆盖层与本地抽象覆盖层
            function renderMergedOverlays(aiOverlays) {
                const effectiveAI = aiOverlays || lastAIOverlays || null;
                const merged = {
                    routes: [
                        ...((localOverlays && localOverlays.routes) || []),
                        ...((effectiveAI && effectiveAI.routes) || [])
                    ],
                    regions: [
                        ...((localOverlays && localOverlays.regions) || []),
                        ...((effectiveAI && effectiveAI.regions) || [])
                    ],
                    labels: [
                        ...((localOverlays && localOverlays.labels) || []),
                        ...((effectiveAI && effectiveAI.labels) || [])
                    ],
                    structures: [
                        ...((localOverlays && localOverlays.structures) || []),
                        ...((effectiveAI && effectiveAI.structures) || [])
                    ],
                    canvas: effectiveAI && effectiveAI.canvas ? effectiveAI.canvas : null
                };
                renderAsciiOverlays(merged);
            }

            function renderMergedEnemyOverlays(aiOverlays) {
                const effectiveAI = aiOverlays || lastAIEnemyOverlays || null;
                const merged = {
                    routes: [
                        ...((localEnemyOverlays && localEnemyOverlays.routes) || []),
                        ...((effectiveAI && effectiveAI.routes) || [])
                    ],
                    regions: [
                        ...((localEnemyOverlays && localEnemyOverlays.regions) || []),
                        ...((effectiveAI && effectiveAI.regions) || [])
                    ],
                    labels: [
                        ...((localEnemyOverlays && localEnemyOverlays.labels) || []),
                        ...((effectiveAI && effectiveAI.labels) || [])
                    ],
                    structures: [
                        ...((localEnemyOverlays && localEnemyOverlays.structures) || []),
                        ...((effectiveAI && effectiveAI.structures) || [])
                    ],
                    canvas: effectiveAI && effectiveAI.canvas ? effectiveAI.canvas : null
                };
                renderAsciiOverlaysEnemy(merged);
            }

            // 基于现有的定居/事件特征，重建本地抽象覆盖层
            function rebuildLocalOverlays() {
                localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                const features = civilization.settlements || [];
                for (const f of features) {
                    const isLarge = !!f.isLarge;
                    switch (f.type) {
                        case 'settlement': {
                            // 更抽象：只用较小半径标记中心，主要由场域画布表现
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                            break;
                        }
                        case 'technology': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 5 : 3, shape: 'hub' });
                            break;
                        }
                        case 'defense': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'fort' });
                            break;
                        }
                        case 'government': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'hub' });
                            break;
                        }
                        case 'conflict': {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 12 : 9, char: 'x' });
                            break;
                        }
                        case 'breakthrough': {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 8, char: '*' });
                            break;
                        }
                        default: {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                        }
                    }
                }
                renderMergedOverlays(null);
                updateFieldCanvas();
                renderAsciiCanvasMerged();
            }

            // 敌方抽象覆盖层
            function rebuildEnemyLocalOverlays() {
                localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                const features = enemy.settlements || [];
                for (const f of features) {
                    const isLarge = !!f.isLarge;
                    switch (f.type) {
                        case 'settlement': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: 'x' });
                            break;
                        }
                        case 'technology': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 5 : 3, shape: 'hub' });
                            break;
                        }
                        case 'defense': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'fort' });
                            break;
                        }
                        case 'government': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'hub' });
                            break;
                        }
                        case 'conflict': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 12 : 9, char: 'x' });
                            break;
                        }
                        case 'breakthrough': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 8, char: '*' });
                            break;
                        }
                        default: {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                        }
                    }
                }
                renderMergedEnemyOverlays(null);
                updateEnemyFieldCanvas();
                renderEnemyAsciiCanvasMerged();
            }

            // 生成本地场域 ASCII 画布
            function generateLocalFieldCanvas(cols = FIELD_CANVAS_COLS, rows = FIELD_CANVAS_ROWS) {
                const features = civilization.settlements || [];
                const grid = new Array(rows);
                for (let j = 0; j < rows; j++) {
                    let rowChars = '';
                    const y = (j + 0.5) / rows * 100;
                    for (let i = 0; i < cols; i++) {
                        const x = (i + 0.5) / cols * 100;
                        let chInt = {
                            settlement: 0,
                            technology: 0,
                            defense: 0,
                            government: 0,
                            conflict: 0,
                            breakthrough: 0
                        };
                        for (const f of features) {
                            // 仅用于渲染的微漂移，不改变真实数据
                            const seed = (f.id % 1000) / 1000;
                            const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const fx = f.x + Math.sin(visualPhase * 1.3 + seed * 6.283) * ampX;
                            const fy = f.y + Math.cos(visualPhase * 1.1 + seed * 6.283) * ampY;
                            const dx = x - fx;
                            const dy = y - fy;
                            const d2 = dx*dx + dy*dy;
                            const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                            const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                            const val = Math.exp(-d2 / (2 * sigma * sigma));
                            chInt[type] += val;
                        }
                        // 轻微的时空闪烁，增加持续演化感
                        const shimmer = 1 + 0.08 * Math.sin(visualPhase * 4 + i * 0.21 + j * 0.37);
                        for (const k in chInt) { chInt[k] *= shimmer; }
                        // 选取主导通道
                        let maxType = 'settlement';
                        let maxVal = -1;
                        for (const k in chInt) {
                            if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; }
                        }
                        // 阈值: 过低则留空
                        if (maxVal < 0.12) {
                            rowChars += ' ';
                        } else {
                            const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                            const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                            rowChars += cs[level];
                        }
                    }
                    grid[j] = rowChars;
                }
                return { grid };
            }

            function updateFieldCanvas() {
                if (!fieldCanvasEnabled) { localFieldCanvas = null; return; }
                localFieldCanvas = generateLocalFieldCanvas();
            }

            function generateLocalEnemyFieldCanvas(cols = FIELD_CANVAS_COLS, rows = FIELD_CANVAS_ROWS) {
                const features = enemy.settlements || [];
                const grid = new Array(rows);
                for (let j = 0; j < rows; j++) {
                    let rowChars = '';
                    const y = (j + 0.5) / rows * 100;
                    for (let i = 0; i < cols; i++) {
                        const x = (i + 0.5) / cols * 100;
                        let chInt = { settlement: 0, technology: 0, defense: 0, government: 0, conflict: 0, breakthrough: 0 };
                        for (const f of features) {
                            const seed = (f.id % 1000) / 1000;
                            const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const fx = f.x + Math.sin(visualPhase * 1.25 + seed * 6.283) * ampX;
                            const fy = f.y + Math.cos(visualPhase * 1.18 + seed * 6.283) * ampY;
                            const dx = x - fx;
                            const dy = y - fy;
                            const d2 = dx*dx + dy*dy;
                            const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                            const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                            const val = Math.exp(-d2 / (2 * sigma * sigma));
                            chInt[type] += val;
                        }
                        const shimmer = 1 + 0.08 * Math.cos(visualPhase * 4.3 + i * 0.19 + j * 0.41);
                        for (const k in chInt) { chInt[k] *= shimmer; }
                        let maxType = 'settlement';
                        let maxVal = -1;
                        for (const k in chInt) { if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; } }
                        if (maxVal < 0.12) { rowChars += ' '; }
                        else {
                            const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                            const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                            rowChars += cs[level];
                        }
                    }
                    grid[j] = rowChars;
                }
                return { grid };
            }

            function updateEnemyFieldCanvas() {
                if (!fieldCanvasEnabled) { localEnemyFieldCanvas = null; return; }
                localEnemyFieldCanvas = generateLocalEnemyFieldCanvas();
            }

            // 合并 AI 与本地场域画布并渲染
            function renderAsciiCanvasMerged() {
                const canvas = document.getElementById('ascii-canvas');
                if (!canvas) return;
                if (!localFieldCanvas && fieldCanvasEnabled) updateFieldCanvas();
                // 优先使用后端权威画布（已由订阅写入 lastAIOverlays.canvas）
                const aiGrid = (lastAIOverlays && lastAIOverlays.canvas && Array.isArray(lastAIOverlays.canvas.grid))
                    ? lastAIOverlays.canvas.grid
                    : null;
                const localGrid = localFieldCanvas ? localFieldCanvas.grid : null;
                let output = [];
                if (localGrid && aiGrid) {
                    const rows = Math.min(localGrid.length, aiGrid.length);
                    for (let j = 0; j < rows; j++) {
                        const a = typeof aiGrid[j] === 'string' ? aiGrid[j] : '';
                        const b = localGrid[j] || '';
                        const cols = Math.min(a.length, b.length);
                        let merged = '';
                        for (let i = 0; i < cols; i++) {
                            const ca = a[i];
                            const cb = b[i];
                            merged += (ca && ca !== ' ') ? ca : cb;
                        }
                        output.push(merged);
                    }
                } else if (aiGrid) {
                    output = aiGrid.slice(0, FIELD_CANVAS_ROWS).map(r => (typeof r === 'string' ? r : ''));
                } else if (localGrid) {
                    output = localGrid;
                } else {
                    output = [];
                }
                canvas.textContent = output.slice(0, FIELD_CANVAS_ROWS).join('\n');
            }

            function renderEnemyAsciiCanvasMerged() {
                const canvas = document.getElementById('ascii-canvas-enemy');
                if (!canvas) return;
                if (!localEnemyFieldCanvas && fieldCanvasEnabled) updateEnemyFieldCanvas();
                const aiGrid = (lastAIEnemyOverlays && lastAIEnemyOverlays.canvas && Array.isArray(lastAIEnemyOverlays.canvas.grid))
                    ? lastAIEnemyOverlays.canvas.grid
                    : null;
                const localGrid = localEnemyFieldCanvas ? localEnemyFieldCanvas.grid : null;
                let output = [];
                if (localGrid && aiGrid) {
                    const rows = Math.min(localGrid.length, aiGrid.length);
                    for (let j = 0; j < rows; j++) {
                        const a = typeof aiGrid[j] === 'string' ? aiGrid[j] : '';
                        const b = localGrid[j] || '';
                        const cols = Math.min(a.length, b.length);
                        let merged = '';
                        for (let i = 0; i < cols; i++) {
                            const ca = a[i];
                            const cb = b[i];
                            merged += (ca && ca !== ' ') ? ca : cb;
                        }
                        output.push(merged);
                    }
                } else if (aiGrid) {
                    output = aiGrid.slice(0, FIELD_CANVAS_ROWS).map(r => (typeof r === 'string' ? r : ''));
                } else if (localGrid) {
                    output = localGrid;
                } else { output = []; }
                canvas.textContent = output.slice(0, FIELD_CANVAS_ROWS).join('\n');
                // PIP 显示我方主画面缩略
                try {
                    const pip = document.getElementById('pip-canvas');
                    const main = document.getElementById('ascii-canvas')?.textContent || '';
                    if (pip && main) {
                        const lines = main.split('\n').slice(0, 28).map(l=>l.slice(0, 70));
                        pip.textContent = lines.join('\n');
                    }
                } catch {}
            }

            // Live HUD 更新
            function pad(n){ return String(n).padStart(2,'0'); }
            function updateLiveHUD(){
                try {
                    const t = (year*365 + day);
                    const hh = pad(Math.floor((t%1440)/60));
                    const mm = pad(t%60);
                    const ss = pad(Math.floor((performance.now()/1000)%60));
                    const clock = document.getElementById('hud-clock');
                    if(clock) clock.textContent = `LIVE ${hh}:${mm}:${ss}`;
                    const viewers = Math.max(1, Math.floor(civilization.population/20 + Math.random()*100));
                    const viewEl = document.getElementById('hud-viewers');
                    if(viewEl) viewEl.textContent = `${viewers} viewers`;
                    const ticker = document.getElementById('hud-ticker');
                    if(ticker){
                        const last = (civilization.events||[]).slice(-3).reverse().map(e=>`${e.type==='positive'?'+':e.type==='negative'?'-':'*'} ${e.message}`).join('  |  ');
                        ticker.textContent = last || 'AI Live · 正在连接…';
                    }
                    // 机位 & 时间码
                    const cam = document.getElementById('hud-cam'); if (cam) cam.textContent = `CAM ${1 + (civilization.stage||0)}`;
                    const tc = document.getElementById('hud-tc'); if (tc) tc.textContent = `TC ${hh}:${mm}:${ss}:00`;
                    // 电量
                    const battPct = Math.max(5, 100 - Math.floor((totalDays%600)/6));
                    const battFill = document.getElementById('hud-batt-fill'); if (battFill) battFill.style.width = `${battPct}%`;
                    const battText = document.getElementById('hud-batt-pct'); if (battText) battText.textContent = `${battPct}%`;
                    // 信号强度
                    const level = 1 + ((Math.floor(performance.now()/2000) + (civilization.stage||0)) % 5);
                    for (let i=1;i<=5;i++) {
                        const bar = document.getElementById(`sig${i}`);
                        if (bar) bar.classList.toggle('sig-on', i<=level);
                    }
                } catch {}
            }

            // 简易弹幕：从事件流随机挑选并播发
            // 弹幕计时器已关闭

            function updateAIMood(score) {
                const face = score > 70 ? ':)' : score < 30 ? ':(' : ':|';
                const label = score > 70 ? '乐观' : score < 30 ? '谨慎' : '平稳';
                const total = 14; // 进度格数
                const filled = Math.round((score / 100) * total);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(total - filled)}] ${Math.round(score)}%`;
                const faceEl = document.getElementById('ai-mood-face');
                const labelEl = document.getElementById('ai-mood-label');
                const barEl = document.getElementById('ai-mood-bar');
                if (faceEl) faceEl.textContent = face;
                if (labelEl) labelEl.textContent = label;
                if (barEl) barEl.textContent = bar;
            }

            async function triggerAI() {
                if (aiPending) return;
                aiPending = true;
                document.getElementById('ai-status').classList.remove('hidden');
                try {
                    const lastEvents = civilization.events.slice(-10);
                    const payload = { state: {
                        day, year, totalDays,
                        population: civilization.population,
                        technology: civilization.technology,
                        stability: civilization.stability,
                        resources: civilization.resources,
                        environment: civilization.environment,
                        economy: civilization.economy,
                        culture: civilization.culture,
                        military: civilization.military,
                        happiness: civilization.happiness,
                        diplomacy: civilization.diplomacy,
                        isDeclining: civilization.isDeclining,
                        stage: civilization.stage
                    }, lastEvents, promptOverrides: { mode, guidelines } };
                    const resp = await fetch(EVOLVE_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const data = await resp.json();
                    applyAIDelta(data);
                    updateUI();
                } catch (e) {
                    addNarrativeEvent('negative', `AI演化请求失败: ${e.message || e}`);
                } finally {
                    aiPending = false;
                    document.getElementById('ai-status').classList.add('hidden');
                }
            }
            
            // 更新文明阶段
            function updateCivilizationStage() {
                // 确定当前阶段
                let newStage = 0;
                for (let i = 0; i < civilizationStages.length; i++) {
                    if (civilization.technology >= civilizationStages[i].minTech && 
                        civilization.technology < civilizationStages[i].maxTech) {
                        newStage = i;
                        break;
                    } else if (civilization.technology >= 100) {
                        newStage = civilizationStages.length - 1;
                        break;
                    }
                }
                
                // 如果阶段变化，记录事件
                if (newStage !== civilization.stage) {
                    civilization.stage = newStage;
                    addEvent('positive', `文明进入了${civilizationStages[newStage].name}`);
                    
                    // 改变进度条颜色
                    if (civilizationStageEl) {
                    civilizationStageEl.style.backgroundColor = civilizationStages[newStage].color;
                    }
                }
                
                // 更新进度条（若存在 DOM 元素）
                let stageProgress = 0;
                if (civilization.technology < 20) {
                    stageProgress = civilization.technology / 20 * 20;
                } else if (civilization.technology < 40) {
                    stageProgress = 20 + (civilization.technology - 20) / 20 * 20;
                } else if (civilization.technology < 60) {
                    stageProgress = 40 + (civilization.technology - 40) / 20 * 20;
                } else if (civilization.technology < 80) {
                    stageProgress = 60 + (civilization.technology - 60) / 20 * 20;
                } else if (civilization.technology < 100) {
                    stageProgress = 80 + (civilization.technology - 80) / 20 * 20;
                } else {
                    stageProgress = 100;
                }
                
                if (civilizationStageEl) {
                    civilizationStageEl.style.width = `${stageProgress}%`;
                }
            }

            // ASCII 风格阶段条
            function updateAsciiStageBar() {
                const totalBlocks = 30;
                const percent = Math.min(100, Math.max(0, civilization.technology));
                const filled = Math.round((percent / 100) * totalBlocks);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(totalBlocks - filled)}] ${Math.round(percent)}%`;
                const label = ['原','农','工','信','空'][civilization.stage] || '';
                const el = document.getElementById('ascii-stage-bar');
                if (el) el.textContent = `${bar} <${label}>`;
            }
            
            // 更新生命周期进度
            function updateLifespanProgress() {
                const percentage = Math.min(100, (totalDays / civilization.lifespan) * 100);
                lifespanPercentage.textContent = `${Math.round(percentage)}%`;
                const totalBlocks = 30;
                const filled = Math.round((percentage / 100) * totalBlocks);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(totalBlocks - filled)}] ${Math.round(percentage)}%`;
                const el = document.getElementById('lifespan-ascii');
                if (el) el.textContent = bar;
                
                // 确定生命周期阶段
                let currentStage = '';
                for (let stage of lifeStages) {
                    if (percentage / 100 >= stage.range[0] && percentage / 100 < stage.range[1]) {
                        currentStage = stage.name;
                        break;
                    }
                }
                lifeStageEl.textContent = `当前阶段: ${currentStage}`;
                
                // 检查是否进入衰退期
                if (percentage > 70 && !civilization.isDeclining) {
                    civilization.isDeclining = true;
                    addEvent('negative', '文明开始显示衰退迹象');
                }
                
                // 检查文明是否终结
                if (percentage >= 100) {
                    addEvent('negative', '文明走到了历史的尽头');
                    pauseSimulation();
                    
                    // 添加一个终结符号
                    addSymbol('conflict', 50, 50, true);
                }
            }
            
            // 添加文明符号
            function addSymbol(type, x, y, isLarge = false) {
                // 仅记录抽象特征，后续用覆盖层渲染大范围符号
                const symbolType = symbolTypes.find(st => st.type === type);
                if (!symbolType) return;
                civilization.settlements.push({
                    id: Date.now(),
                    type,
                    x,
                    y,
                    isLarge: !!isLarge,
                    age: 0
                });
                rebuildLocalOverlays();
            }

            function addEnemySymbol(type, x, y, isLarge = false) {
                const symbolType = symbolTypes.find(st => st.type === type);
                if (!symbolType) return;
                enemy.settlements.push({
                    id: Date.now() + Math.floor(Math.random()*1000),
                    type,
                    x,
                    y,
                    isLarge: !!isLarge,
                    age: 0
                });
                rebuildEnemyLocalOverlays();
            }
            
            // 随机添加符号
            function addRandomSymbol() {
                // 随机选择符号类型
                let random = Math.random() * 100;
                let selectedType = null;
                
                for (let type of symbolTypes) {
                    random -= type.chance;
                    if (random <= 0) {
                        selectedType = type.type;
                        break;
                    }
                }
                
                // 随机位置
                const x = Math.random() * 80 + 10; // 10-90%
                const y = Math.random() * 80 + 10; // 10-90%
                
                // 添加符号
                addSymbol(selectedType, x, y);
            }
            
            // 更新符号状态
            function updateSymbols() {
                // 随机移除一些旧特征
                if (civilization.settlements.length > 50 && Math.random() < 0.1) {
                    let oldest = null;
                    for (const s of civilization.settlements) {
                        if (!oldest || s.age > oldest.age) oldest = s;
                    }
                    if (oldest) {
                        civilization.settlements = civilization.settlements.filter(s => s.id !== oldest.id);
                    }
                }
                // 年龄递增
                civilization.settlements.forEach(s => { s.age++; });
                // 重建抽象覆盖层
                rebuildLocalOverlays();
            }

            function updateEnemySymbols() {
                if (enemy.settlements.length > 50 && Math.random() < 0.1) {
                    let oldest = null;
                    for (const s of enemy.settlements) { if (!oldest || s.age > oldest.age) oldest = s; }
                    if (oldest) enemy.settlements = enemy.settlements.filter(s => s.id !== oldest.id);
                }
                enemy.settlements.forEach(s => { s.age++; });
                rebuildEnemyLocalOverlays();
            }
            
            // 添加事件
            function addEvent(eventType, customMessage = null) {
                // 查找事件类型
                const eventGroup = eventTypes.find(et => et.type === eventType);
                if (!eventGroup) return;
                
                // 选择消息
                const message = customMessage || eventGroup.messages[Math.floor(Math.random() * eventGroup.messages.length)];
                
                // 应用事件效果
                civilization.population = Math.max(1, civilization.population + (eventGroup.effects.population || 0));
                civilization.technology = Math.max(0, Math.min(100, civilization.technology + (eventGroup.effects.technology || 0)));
                civilization.stability = Math.max(0, Math.min(100, civilization.stability + (eventGroup.effects.stability || 0)));
                
                // 创建事件元素
                const eventEl = document.createElement('pre');
                eventEl.className = 'font-mono text-xs p-2 rounded-lg bg-gray-800/60 text-gray-300 whitespace-pre-wrap';
                const prefix = eventType === 'positive' ? '[+]' : eventType === 'negative' ? '[-]' : '[*]';
                eventEl.textContent = `${prefix} ${year}年${day}天 | ${message}`;
                
                // 添加到日志顶部
                if (eventLogEl.firstChild) {
                    eventLogEl.insertBefore(eventEl, eventLogEl.firstChild);
                } else {
                    eventLogEl.appendChild(eventEl);
                }
                
                // 自动滚动到顶部
                eventLogEl.scrollTop = 0;
                
                // 记录事件
                civilization.events.push({
                    day: totalDays,
                    type: eventType,
                    message
                });
                
                // 更新最后事件日期
                civilization.lastEventDay = totalDays;
            }
            
            // 随机事件
            function randomEvent() {
                // 每7-14天发生一个事件
                const daysSinceLastEvent = totalDays - civilization.lastEventDay;
                if (daysSinceLastEvent < 7 || Math.random() > 1 / (14 - daysSinceLastEvent)) {
                    return;
                }
                
                // 基于文明稳定性调整事件概率
                let eventChance = { positive: 0.3, negative: 0.3, neutral: 0.4 };
                // 模式加权
                if (mode === 'peace') {
                    eventChance.positive += 0.15;
                    eventChance.negative -= 0.15;
                } else if (mode === 'disaster') {
                    eventChance.positive -= 0.15;
                    eventChance.negative += 0.15;
                }
                
                // 稳定性高时更可能发生积极事件
                if (civilization.stability > 70) {
                    eventChance.positive += 0.2;
                    eventChance.negative -= 0.2;
                } 
                // 稳定性低时更可能发生消极事件
                else if (civilization.stability < 30) {
                    eventChance.positive -= 0.2;
                    eventChance.negative += 0.2;
                }
                
                // 衰退期更可能发生消极事件
                if (civilization.isDeclining) {
                    eventChance.positive -= 0.1;
                    eventChance.negative += 0.1;
                }
                
                // 确保概率不为负
                eventChance.positive = Math.max(0, eventChance.positive);
                eventChance.negative = Math.max(0, eventChance.negative);
                eventChance.neutral = 1 - eventChance.positive - eventChance.negative;
                
                // 随机选择事件类型
                let random = Math.random();
                let eventType;
                
                if (random < eventChance.positive) {
                    eventType = 'positive';
                } else if (random < eventChance.positive + eventChance.negative) {
                    eventType = 'negative';
                } else {
                    eventType = 'neutral';
                }
                
                // 添加事件
                addEvent(eventType);
            }
            
            // 模拟一天的变化
            function simulateDay() {
                // 更新时间
                day++;
                totalDays++;
                if (day >= 365) {
                    day = 0;
                    year++;
                }
                
                // 移除本地自然演化，交由云端权威
                
                // 随机添加符号
                if (Math.random() < 0.1 && civilization.settlements.length < 100) {
                    addRandomSymbol();
                }
                // 敌方随机成长
                if (Math.random() < 0.08 && enemy.settlements.length < 100) {
                    const x = Math.random() * 80 + 10;
                    const y = Math.random() * 80 + 10;
                    const types = ['settlement','technology','defense','government','conflict'];
                    addEnemySymbol(types[Math.floor(Math.random()*types.length)], x, y);
                }
                
                // 更新符号状态
                updateSymbols();
                updateEnemySymbols();
                
                // 随机事件
                randomEvent();
                // 本地触发 AI（异步）
                if (aiEnabled && (totalDays % aiFrequency === 0)) {
                    setTimeout(() => { triggerAI(); }, 0);
                }
                
                // 更新UI（只读渲染依旧）
                updateUI();
            }
            
            // 开始模拟
            function startSimulation() {
                if (isRunning) return;
                
                isRunning = true;
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
                
                // 根据速度设置间隔 (1x = 1秒 = 1天)
                const intervalTime = 1000 / simulationSpeed;
                
                simulationInterval = setInterval(simulateDay, intervalTime);
            }
            
            // 暂停模拟
            function pauseSimulation() {
                if (!isRunning) return;
                
                isRunning = false;
                clearInterval(simulationInterval);
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
            }
            
            // 切换模拟速度
            function toggleSpeed() {
                const speeds = [1, 2, 4, 8];
                const speedLabels = ['1x 速度', '2x 速度', '4x 速度', '8x 速度'];
                
                // 找到当前速度索引
                let currentIndex = speeds.indexOf(simulationSpeed);
                
                // 切换到下一个速度
                currentIndex = (currentIndex + 1) % speeds.length;
                simulationSpeed = speeds[currentIndex];
                speedText.textContent = speedLabels[currentIndex];
                
                // 如果正在运行，重新启动间隔以应用新速度
                if (isRunning) {
                    clearInterval(simulationInterval);
                    const intervalTime = 1000 / simulationSpeed;
                    simulationInterval = setInterval(simulateDay, intervalTime);
                }
            }

            // 切换AI
            function toggleAI() {
                aiEnabled = !aiEnabled;
                const aiText = document.getElementById('ai-toggle-text');
                aiText.textContent = aiEnabled ? 'AI演化 开启' : 'AI演化 关闭';
                const btn = document.getElementById('ai-toggle-btn');
                if (aiEnabled) {
                    btn.classList.remove('bg-gray-700');
                    btn.classList.add('bg-success/20');
                } else {
                    btn.classList.add('bg-gray-700');
                }
            }
            
            // 格式化大数字
            function formatNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return Math.round(num).toString();
            }
            
            // 显示关于模态框
            function showAboutModal() {}
            
            // 隐藏关于模态框
            function hideAboutModal() {}
            
            // 切换移动菜单
            function toggleMobileMenu() {
                mobileMenu.classList.toggle('hidden');
            }
            
            // 订阅云端权威状态（包含画布），用户共享同一演化
            try {
                if (window.firebase && firebase.firestore && window.__FIREBASE_CONFIG__ && window.__FIREBASE_CONFIG__.projectId) {
                    firebase.initializeApp?.(window.__FIREBASE_CONFIG__);
                    const db = firebase.firestore();
                    db.collection('sim').doc('state').onSnapshot((snap) => {
                        const s = snap?.data?.() || null; if (!s) return;
                        // 注入权威画布供 render 函数使用
                        lastAIOverlays = { ...(lastAIOverlays||{}), canvas: s.canvas || null };
                        // 同步核心数值
                        civilization.population = s.population ?? civilization.population;
                        civilization.technology = s.technology ?? civilization.technology;
                        civilization.stability = s.stability ?? civilization.stability;
                        civilization.resources = s.resources ?? civilization.resources;
                        civilization.environment = s.environment ?? civilization.environment;
                        civilization.economy = s.economy ?? civilization.economy;
                        civilization.culture = s.culture ?? civilization.culture;
                        civilization.military = s.military ?? civilization.military;
                        civilization.happiness = s.happiness ?? civilization.happiness;
                        civilization.diplomacy = s.diplomacy ?? civilization.diplomacy;
                        day = s.day ?? day; year = s.year ?? year; totalDays = s.totalDays ?? totalDays;
                        updateUI();
                    });
                    db.collection('sim').doc('enemy').onSnapshot((snap) => {
                        const e = snap?.data?.() || null; if (!e) return;
                        lastAIEnemyOverlays = { ...(lastAIEnemyOverlays||{}), canvas: e.canvas || null };
                    });
                }
            } catch {}
            
            // 事件监听器
            startBtn.addEventListener('click', startSimulation);
            pauseBtn.addEventListener('click', pauseSimulation);
            speedBtn.addEventListener('click', toggleSpeed);
            document.getElementById('ai-toggle-btn').addEventListener('click', toggleAI);
            document.getElementById('ai-frequency').addEventListener('change', (e) => {
                aiFrequency = parseInt(e.target.value || '3', 10);
            });
            document.getElementById('ai-trigger-btn').addEventListener('click', () => { triggerAI(); });
            document.getElementById('mode-select').addEventListener('change', (e) => {
                mode = e.target.value;
                addNarrativeEvent('neutral', `模式切换为：${mode === 'peace' ? '和平' : mode === 'disaster' ? '灾变' : '标准'}`);
            });
            document.getElementById('autosave-toggle').addEventListener('change', (e) => {
                autosaveEnabled = !!e.target.checked;
                if (autosaveEnabled) saveSnapshot();
            });
            document.getElementById('guidelines-input').addEventListener('input', (e) => {
                guidelines = e.target.value || '';
                if (autosaveEnabled) saveSnapshot();
            });
            resetBtn.addEventListener('click', async () => {
                try {
                    // 云端重置
                    const resetUrl = (location.hostname==='localhost'||location.hostname==='127.0.0.1')
                        ? 'http://localhost:5001/chat-294cc/us-central1/resetState'
                        : 'https://us-central1-chat-294cc.cloudfunctions.net/resetState';
                    await fetch(resetUrl, { method:'POST' });
                } catch {}
                // 本地界面同步清空
                pauseSimulation();
                initialize();
            });
            mobileResetBtn.addEventListener('click', () => {
                toggleMobileMenu();
                pauseSimulation();
                initialize();
            });
            // 关于按钮已禁用
            mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            
            // 点击模态框外部关闭
            // 关于模态框已移除
            
            // 存档/读档
            function getUserId(){
                try {
                    let id = localStorage.getItem('ai-civ-user-id');
                    if (!id) {
                        id = (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : `u_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                        localStorage.setItem('ai-civ-user-id', id);
                    }
                    return id;
                } catch { return 'u_default'; }
            }
            function getSnapKey(){ return `ai-civ-sim:${getUserId()}`; }
            function saveSnapshot() {
                try {
                    const snapshot = {
                        civilization,
                        day, year, totalDays,
                        aiEnabled, aiFrequency, mode, guidelines, autosaveEnabled
                    };
                    localStorage.setItem(getSnapKey(), JSON.stringify(snapshot));
                } catch {}
            }
            function loadSnapshot() {
                try {
                    const raw = localStorage.getItem(getSnapKey());
                    if (!raw) return false;
                    const snap = JSON.parse(raw);
                    if (!snap || !snap.civilization) return false;
                    civilization = snap.civilization;
                    day = snap.day || 0; year = snap.year || 0; totalDays = snap.totalDays || 0;
                    aiEnabled = !!snap.aiEnabled;
                    aiFrequency = snap.aiFrequency || 3;
                    mode = snap.mode || 'normal';
                    guidelines = snap.guidelines || '';
                    autosaveEnabled = snap.autosaveEnabled !== false;
                    // 同步控件
                    document.getElementById('ai-toggle-text').textContent = aiEnabled ? 'AI演化 开启' : 'AI演化 关闭';
                    document.getElementById('ai-frequency').value = String(aiFrequency);
                    document.getElementById('mode-select').value = mode;
                    document.getElementById('guidelines-input').value = guidelines;
                    document.getElementById('autosave-toggle').checked = autosaveEnabled;
                    updateUI();
                    return true;
                } catch {
                    return false;
                }
            }

            // 初始化模拟（每用户本地存档）
            if (!loadSnapshot()) {
                initialize();
            } else {
                // 隐藏加载状态（读档无需加载遮罩）
                loadingOverlay.classList.add('hidden');
            }
            // 确保视觉循环已启动
            startVisualLoop();

            // 默认自动开始并开启 AI 演化
            try {
                aiEnabled = true;
                const aiText = document.getElementById('ai-toggle-text');
                if (aiText) aiText.textContent = 'AI演化 开启';
                const btn = document.getElementById('ai-toggle-btn');
                if (btn) { btn.classList.remove('bg-gray-700'); btn.classList.add('bg-success/20'); }
                startSimulation();
            } catch {}

            // 预初始化网格，便于逐行更新
            function ensureFieldGrids() {
                if (!localFieldCanvas || !Array.isArray(localFieldCanvas.grid) || localFieldCanvas.grid.length !== FIELD_CANVAS_ROWS) {
                    localFieldCanvas = { grid: new Array(FIELD_CANVAS_ROWS).fill('').map(() => ' '.repeat(FIELD_CANVAS_COLS)) };
                }
                if (!localEnemyFieldCanvas || !Array.isArray(localEnemyFieldCanvas.grid) || localEnemyFieldCanvas.grid.length !== FIELD_CANVAS_ROWS) {
                    localEnemyFieldCanvas = { grid: new Array(FIELD_CANVAS_ROWS).fill('').map(() => ' '.repeat(FIELD_CANVAS_COLS)) };
                }
                if (!Array.isArray(localInfluenceGrid) || localInfluenceGrid.length !== FIELD_CANVAS_ROWS) {
                    localInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
                }
                if (!Array.isArray(enemyInfluenceGrid) || enemyInfluenceGrid.length !== FIELD_CANVAS_ROWS) {
                    enemyInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
                }
            }

            function computeFieldRow(features, j, cols, rows, isEnemy) {
                const y = (j + 0.5) / rows * 100;
                let rowChars = '';
                const strengths = new Float32Array(cols);
                for (let i = 0; i < cols; i++) {
                    const x = (i + 0.5) / cols * 100;
                    let chInt = { settlement: 0, technology: 0, defense: 0, government: 0, conflict: 0, breakthrough: 0 };
                    for (const f of features) {
                        const seed = (f.id % 1000) / 1000;
                        const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                        const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                        const fx = f.x + Math.sin(visualPhase * (isEnemy ? 1.25 : 1.3) + seed * 6.283) * ampX;
                        const fy = f.y + Math.cos(visualPhase * (isEnemy ? 1.18 : 1.1) + seed * 6.283) * ampY;
                        const dx = x - fx;
                        const dy = y - fy;
                        const d2 = dx*dx + dy*dy;
                        const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                        const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                        const val = Math.exp(-d2 / (2 * sigma * sigma));
                        chInt[type] += val;
                    }
                    const shimmer = 1 + 0.08 * (isEnemy
                        ? Math.cos(visualPhase * 4.3 + i * 0.19 + j * 0.41)
                        : Math.sin(visualPhase * 4.0 + i * 0.21 + j * 0.37));
                    for (const k in chInt) { chInt[k] *= shimmer; }
                    let maxType = 'settlement'; let maxVal = -1;
                    for (const k in chInt) { if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; } }
                    strengths[i] = maxVal;
                    if (maxVal < 0.12) { rowChars += ' '; }
                    else {
                        const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                        const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                        rowChars += cs[level];
                    }
                }
                return { rowChars, strengths };
            }

            function updateFieldCanvasStep() {
                ensureFieldGrids();
                const features = civilization.settlements || [];
                for (let n = 0; n < ROWS_PER_FRAME; n++) {
                    const j = rowCursorLocal % FIELD_CANVAS_ROWS;
                    const res = computeFieldRow(features, j, FIELD_CANVAS_COLS, FIELD_CANVAS_ROWS, false);
                    localFieldCanvas.grid[j] = res.rowChars;
                    localInfluenceGrid[j] = res.strengths;
                    rowCursorLocal++;
                }
            }

            function updateEnemyFieldCanvasStep() {
                ensureFieldGrids();
                const features = enemy.settlements || [];
                for (let n = 0; n < ROWS_PER_FRAME; n++) {
                    const j = rowCursorEnemy % FIELD_CANVAS_ROWS;
                    const res = computeFieldRow(features, j, FIELD_CANVAS_COLS, FIELD_CANVAS_ROWS, true);
                    localEnemyFieldCanvas.grid[j] = res.rowChars;
                    enemyInfluenceGrid[j] = res.strengths;
                    rowCursorEnemy++;
                }
            }

            // 持续视觉循环（requestAnimationFrame）
            function startVisualLoop() {
                if (rafId) { try { cancelAnimationFrame(rafId); } catch {} }
                ensureFieldGrids();
                const tick = () => {
                    visualPhase += 0.06;
                    updateFieldCanvasStep();
                    updateEnemyFieldCanvasStep();
                    frameParity ^= 1;
                    if (frameParity === 0) {
                        renderAsciiCanvasMerged();
                        renderEnemyAsciiCanvasMerged();
                    }
                    rafId = requestAnimationFrame(tick);
                };
                rafId = requestAnimationFrame(tick);
            }
            function stopVisualLoop() {
                if (rafId) { try { cancelAnimationFrame(rafId); } catch {} }
                rafId = null;
            }
        });
    </script>
</body>
</html>
