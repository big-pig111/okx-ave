<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Civilization Simulator - Rise and Fall</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' fill='black'/%3E%3Ctext x='8' y='42' font-size='32' fill='%2322c55e' font-family='monospace'%3EAI%3C/text%3E%3C/svg%3E"/>
    <!-- Firebase SDK (compat) for realtime sync -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script>
        // Firebase Web Configuration
        window.__FIREBASE_CONFIG__ = window.__FIREBASE_CONFIG__ || {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };
    </script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#FF7D00',
                        success: '#00B42A',
                        warning: '#FF7D00',
                        danger: '#F53F3F',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .simulation-grid {
                background-size: 32px 16px;
                background-image:
                    linear-gradient(to right, rgba(0,255,0,0.25) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(0,255,0,0.25) 1px, transparent 1px);
            }
            .ascii-btn { color: #22c55e; }
            .ascii-select { color: #22c55e; background: transparent; border: 1px dashed rgba(34,197,94,0.4); padding: 2px 6px; }
            .ascii-card { border: 1px solid rgba(34,197,94,0.4); }
            /* Live HUD styles */
            @keyframes hud-blink { 0%,49%{opacity:1} 50%,100%{opacity:.25} }
            .hud-rec { animation: hud-blink 1s linear infinite; }
            .scanlines { pointer-events:none; background: repeating-linear-gradient(to bottom, rgba(34,197,94,0.08) 0 1px, transparent 1px 3px); mix-blend-mode: screen; }
            .vignette { pointer-events:none; box-shadow: inset 0 0 220px rgba(0,0,0,0.8); }
            @keyframes cam-drift { 0%{transform: translate(0,0) scale(1)} 50%{transform: translate(3px,-2px) scale(1.01)} 100%{transform: translate(0,0) scale(1)} }
            .cam-drift { animation: cam-drift 6s ease-in-out infinite; }
            @keyframes marquee {
                0% { transform: translateX(100%); }
                100% { transform: translateX(-100%); }
            }
            .marquee { white-space: nowrap; will-change: transform; animation: marquee 18s linear infinite; }
            .hud-batt { width: 56px; height: 12px; border: 1px solid rgba(34,197,94,0.6); position: relative; }
            .hud-batt::after { content: ""; position: absolute; right: -4px; top: 3px; width: 3px; height: 6px; border: 1px solid rgba(34,197,94,0.6); }
            .hud-batt-fill { height: 100%; background: linear-gradient(90deg, rgba(34,197,94,0.9), rgba(34,197,94,0.6)); }
            .sig-bar { width: 5px; background: rgba(34,197,94,0.4); }
            .sig-on { background: rgba(34,197,94,0.95); }
            .pip { position:absolute; left:10px; top:40px; width:220px; height:140px; background: rgba(0,0,0,0.55); border:1px solid rgba(34,197,94,0.4); box-shadow: 0 0 18px rgba(0,0,0,0.5); }
            .pip pre { font-size: 8px; line-height: 10px; padding:6px; color:#34d399; }
            .channel-title { position:absolute; top:8px; left:50%; transform:translateX(-50%); background: rgba(0,0,0,0.45); border:1px solid rgba(34,197,94,0.4); padding:3px 8px; font-size:12px; letter-spacing:1px; }
            /* Danmaku disabled */
        }
    </style>
</head>
<body class="bg-black text-green-300 min-h-screen flex flex-col font-mono">
    <!-- Top Navigation Bar -->
    <header class="bg-black/90 border-b border-green-800 sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <span class="text-primary text-2xl">[CIV]</span>
                <h1 class="text-xl md:text-2xl font-bold text-gray-200">Civilization Simulator</h1>
            </div>
            
            <div class="hidden md:flex items-center space-x-6">
                <button id="about-btn" class="hover:text-primary transition-colors duration-200 hidden">[ About ]</button>
                <button id="reset-btn" class="hover:text-primary transition-colors duration-200">[ Reset ]</button>
            </div>
            
            <div class="flex md:hidden">
                <button id="mobile-menu-btn" class="text-gray-300 hover:text-white text-xl">[≡]</button>
            </div>
        </div>
        
        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden md:hidden bg-black/95 border-t border-green-800">
            <div class="container mx-auto px-4 py-2 flex flex-col space-y-3">
                <button id="mobile-about-btn" class="py-2 text-green-300 text-left hidden">[ About ]</button>
                <button id="mobile-reset-btn" class="py-2 text-green-300 text-left">[ Reset ]</button>
            </div>
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow container mx-auto px-4 py-6 md:py-10">
        <!-- Control Panel -->
        <div class="bg-dark/50 border border-gray-800 p-4 mb-6">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                <div class="flex items-center space-x-4">
                    <button id="start-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200">[ Start ]</button>
                    <button id="pause-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200 hidden">[ Pause ]</button>
                    <button id="speed-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-all duration-200 hidden">[ <span id="speed-text">1x Speed</span> ]</button>
                </div>

                <div class="flex items-center space-x-3 w-full md:w-auto">
                    <button id="ai-toggle-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-3 py-2 rounded-lg transition-all duration-200">[ <span id="ai-toggle-text">AI Evolution OFF</span> ]</button>
                    <div class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2">
                        <span class="mr-2 text-gray-400">[Freq]</span>
                        <select id="ai-frequency" class="bg-transparent text-sm outline-none">
                            <option value="1">Every 1 day</option>
                            <option value="3" selected>Every 3 days</option>
                            <option value="7">Every 7 days</option>
                            <option value="14">Every 14 days</option>
                        </select>
                    </div>
                    <div class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2">
                        <span class="mr-2 text-gray-400">[Mode]</span>
                        <select id="mode-select" class="bg-transparent text-sm outline-none">
                            <option value="peace">Peace</option>
                            <option value="normal" selected>Normal</option>
                            <option value="disaster">Disaster</option>
                        </select>
                    </div>
                    <label class="flex items-center bg-dark/70 border border-gray-800 rounded-lg px-3 py-2 cursor-pointer select-none">[ Auto-save ]<input id="autosave-toggle" type="checkbox" class="ml-2"></label>
                    <button id="ai-trigger-btn" class="bg-gray-800 hover:bg-gray-700 text-white px-3 py-2 rounded-lg transition-all duration-200">[ Evolve Now ]</button>
                    <div id="ai-status" class="text-xs text-gray-400 hidden">( Computing ... )</div>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 w-full md:w-auto">
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌─ Sim Time ─┐
│ <span id="simulation-time">0Y 0D</span>
└────────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Population ┐
│ <span id="population">0</span>
└────────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Technology ┐
│ <span id="technology">0</span>
└────────────┘</pre>
                    <pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌─ Stability ┐
│ <span id="stability">0%</span>
└─────────────┘</pre>
                </div>
            </div>
        </div>
        
        <!-- Civilization Stage Indicator -->
        <div class="mb-6">
            <div class="flex justify-between text-xs text-gray-400 mb-1">
                <span>Primitive</span>
                <span>Agricultural</span>
                <span>Industrial</span>
                <span>Information</span>
                <span>Space Age</span>
            </div>
            <div id="ascii-stage-bar" class="font-mono text-xs text-green-400 mt-1"></div>
        </div>
        
        <!-- Civilization Simulation Area -->
        <div class="relative bg-dark/50 border border-gray-800 p-4 md:p-6 mb-6 overflow-hidden">
            <div id="simulation-area" class="simulation-grid w-full aspect-[16/9] overflow-hidden relative">
                <!-- Civilization symbols will be dynamically generated here -->
                <div id="civilization-symbols" class="w-full h-full"></div>
                <!-- ASCII Overlay (routes/regions/labels/structures) -->
                <div id="ascii-overlays" class="pointer-events-none absolute inset-0"></div>
                <!-- ASCII Canvas (full frame snapshot) -->
                <pre id="ascii-canvas" class="absolute inset-0 m-0 p-2 text-[10px] leading-3 overflow-hidden whitespace-pre text-green-400 pointer-events-none"></pre>
                <!-- Enemy ASCII Overlay (red) -->
                <div id="ascii-overlays-enemy" class="pointer-events-none absolute inset-0"></div>
                <!-- Enemy ASCII Canvas (full frame snapshot, red) -->
                <pre id="ascii-canvas-enemy" class="absolute inset-0 m-0 p-2 text-[10px] leading-3 overflow-hidden whitespace-pre text-red-400 pointer-events-none"></pre>
                <!-- Faction Legend -->
                <div class="pointer-events-none absolute right-2 bottom-2 bg-black/40 border border-gray-700 rounded px-2 py-1 text-[11px] leading-4">
                    <div><span class="text-green-400">■</span> chat-gpt5</div>
                    <div><span class="text-red-400">■</span> claude-4.1</div>
                </div>
                <!-- Live HUD overlay -->
                <div id="live-hud" class="pointer-events-none absolute inset-0 flex flex-col justify-between select-none">
                    <div class="channel-title text-green-300">AI Civilization Live · AICAST</div>
                    <div class="flex justify-between items-start p-3 text-[12px]">
                        <div class="flex items-center gap-3">
                            <span class="hud-rec inline-block w-3.5 h-3.5 rounded-full bg-red-500"></span>
                            <span class="text-red-400 font-semibold tracking-widest">REC</span>
                            <span id="hud-viewers" class="ml-3 text-green-300">0 viewers</span>
                        </div>
                        <div class="flex items-center gap-4">
                            <span id="hud-clock" class="text-green-300 text-[14px] font-semibold">LIVE 00:00:00</span>
                            <span id="hud-cam" class="text-green-300">CAM 1</span>
                            <span id="hud-tc" class="text-green-300">TC 00:00:00:00</span>
                            <div class="flex items-center gap-2">
                                <div class="hud-batt"><div id="hud-batt-fill" class="hud-batt-fill" style="width:100%"></div></div>
                                <span id="hud-batt-pct" class="text-green-300">100%</span>
                            </div>
                            <div id="hud-signal" class="flex items-end gap-1">
                                <span id="sig1" class="sig-bar h-1.5"></span>
                                <span id="sig2" class="sig-bar h-3"></span>
                                <span id="sig3" class="sig-bar h-4.5"></span>
                                <span id="sig4" class="sig-bar h-6"></span>
                                <span id="sig5" class="sig-bar h-7.5"></span>
                            </div>
                        </div>
                    </div>
                    <div class="px-3 pb-2 relative">
                        <div class="overflow-hidden border-t border-green-800/60">
                            <div id="hud-ticker" class="marquee text-[12px] py-1.5 text-green-400"></div>
                        </div>
                    </div>
                    <div class="absolute inset-0 scanlines"></div>
                    <div class="absolute inset-0 vignette"></div>
                    <div class="pip"><pre id="pip-canvas"></pre></div>
                    <!-- Danmaku disabled -->
                </div>
                
                <!-- Loading Overlay -->
                <div id="loading-overlay" class="absolute inset-0 bg-dark/80 flex flex-col items-center justify-center z-10">
                    <div class="text-4xl text-primary mb-4 animate-spin">◌</div>
                    <p class="text-lg">Initializing Civilization...</p>
                </div>
            </div>
        </div>
        
        <!-- Event Log and Statistics -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Event Log -->
            <div class="lg:col-span-2 bg-dark/50 border border-gray-800 p-4">
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ Civilization Chronicle ]</h2>
                <div id="event-log" class="h-64 overflow-y-auto pr-2 text-sm space-y-2">
                    <p class="text-gray-400 italic">Civilization development events will appear after simulation starts...</p>
                </div>
            </div>
            
            <!-- AI Guidelines + Indicators and Symbol Explanations -->
            <div class="bg-dark/50 border border-gray-800 p-4">
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ AI Guidelines (Optional) ]</h2>
                <textarea id="guidelines-input" class="w-full bg-dark/70 border border-gray-800 rounded-lg p-3 text-sm mb-4 outline-none" rows="3" placeholder="Hints for AI evolution direction, e.g.: Prioritize green development, reduce war probability..."></textarea>
                <div class="mb-4">
<pre class="bg-black/60 rounded-lg p-3 border border-green-800 text-xs leading-5 whitespace-pre-wrap">┌── AI Mood ──┐
│ <span id="ai-mood-face">:|</span>  <span id="ai-mood-label">Stable</span>
│ <span id="ai-mood-bar">[..............] 0%</span>
└─────────────┘</pre>
                </div>
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ Civilization Indicators ]</h2>
                <div class="grid grid-cols-2 gap-3 text-sm mb-4">
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Resources ┐
│ <span id="resources">50</span>
└────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Environment┐
│ <span id="environment">50</span>
└─────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── Economy ┐
│ <span id="economy">50</span>
└────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌── Culture ┐
│ <span id="culture">50</span>
└────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌─ Military ┐
│ <span id="military">50</span>
└────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Happiness ┐
│ <span id="happiness">50</span>
└────────────┘</pre>
<pre class="bg-dark/70 rounded-lg p-3 border border-gray-800 text-xs leading-5 whitespace-pre-wrap">┌ Diplomacy ┐
│ <span id="diplomacy">50</span>
└────────────┘</pre>
                </div>
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ Symbol Legend ]</h2>
                <div class="space-y-2 text-sm font-mono">
                    <div>[Settlement Field] Settlement influence (denser = stronger)</div>
                    <div>[Tech Diffusion] Network/innovation spread (+ and * density)</div>
                    <div>[Defense Density] Fortress zones (# gradient)</div>
                    <div>[Governance Hubs] Hubs and channels (H and - patterns)</div>
                    <div>[Conflict Rifts] Tension and fractures (x/X fault lines)</div>
                    <div>[Breakthrough Nebula] Breakthrough overflow (* clusters)</div>
                </div>
                
                <hr class="my-4 border-gray-800">
                
                <!-- Civilization Lifecycle Indicator -->
                <h2 class="text-lg font-semibold mb-3 flex items-center">[ Civilization Lifecycle ]</h2>
                <div class="relative pt-1">
                    <div class="flex mb-2 items-center justify-between">
                        <div>
                            <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-primary/80 bg-primary/10">
                                Lifecycle
                            </span>
                        </div>
                        <div class="text-right">
                            <span id="lifespan-percentage" class="text-xs font-semibold inline-block text-primary">
                                0%
                            </span>
                        </div>
                    </div>
                    <pre id="lifespan-ascii" class="font-mono text-xs text-green-400"></pre>
                </div>
                <p id="life-stage" class="text-center text-sm text-gray-400 italic">Awaiting civilization birth...</p>
            </div>
        </div>
    </main>

    <!-- About modal disabled -->

    <script>
        // Civilization Simulator Core Logic
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Element References
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const speedBtn = document.getElementById('speed-btn');
            const speedText = document.getElementById('speed-text');
            const resetBtn = document.getElementById('reset-btn');
            const mobileResetBtn = document.getElementById('mobile-reset-btn');
            const aboutBtn = null;
            const mobileAboutBtn = null;
            const closeAboutBtn = null;
            const startFromAboutBtn = null;
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenu = document.getElementById('mobile-menu');
            const simulationTimeEl = document.getElementById('simulation-time');
            const populationEl = document.getElementById('population');
            const technologyEl = document.getElementById('technology');
            const stabilityEl = document.getElementById('stability');
            const civilizationStageEl = document.getElementById('civilization-stage');
            const eventLogEl = document.getElementById('event-log');
            const simulationArea = document.getElementById('simulation-area');
            const civilizationSymbols = document.getElementById('civilization-symbols');
            const loadingOverlay = document.getElementById('loading-overlay');
            const lifespanProgress = document.getElementById('lifespan-progress');
            const lifespanPercentage = document.getElementById('lifespan-percentage');
            const lifeStageEl = document.getElementById('life-stage');
            const aboutModal = null;
            // Wrap visual layers to create camera drift effect
            try {
                const area = document.getElementById('simulation-area');
                const cam = document.createElement('div');
                cam.setAttribute('id','camera-content');
                cam.setAttribute('class','absolute inset-0 cam-drift');
                // Move main layers under camera-content
                const moveIds = ['civilization-symbols','ascii-overlays','ascii-canvas','ascii-overlays-enemy','ascii-canvas-enemy'];
                moveIds.forEach(id=>{ const el = document.getElementById(id); if(el){ cam.appendChild(el); }});
                area.insertBefore(cam, area.firstChild);
            } catch {}
            
            // Simulation State Variables
            let isRunning = false;
            let simulationSpeed = 1; // 1x, 2x, 4x, 8x
            let simulationInterval;
            let day = 0;
            let year = 0;
            let totalDays = 0;
            let aiEnabled = false;
            let aiFrequency = 3; // days
            let aiPending = false;
            let mode = 'normal';
            let autosaveEnabled = true;
            let guidelines = '';
            
            // Civilization Attributes
            let civilization = {
                population: 10,
                technology: 0,
                stability: 50,
                resources: 50,
                environment: 50,
                economy: 50,
                culture: 50,
                military: 50,
                happiness: 50,
                diplomacy: 50,
                settlements: [],
                events: [],
                stage: 0, // 0-4 corresponds to five civilization stages
                lifespan: Math.floor(Math.random() * 3000) + 2000, // Civilization expected lifespan (days)
                isDeclining: false,
                lastEventDay: 0
            };
            // Enemy Attributes
            let enemy = {
                population: 8,
                technology: 0,
                stability: 50,
                resources: 50,
                environment: 50,
                economy: 50,
                culture: 50,
                military: 55,
                happiness: 45,
                diplomacy: 30,
                settlements: [],
                stage: 0,
                isDeclining: false
            };
            
            // Civilization Symbol Type Definitions
            const symbolTypes = [
                { type: 'settlement', label: '●', color: 'bg-success/20 text-success', chance: 30 },       // Settlement
                { type: 'technology', label: '△', color: 'bg-primary/20 text-primary', chance: 20 },     // Technology
                { type: 'defense', label: '□', color: 'bg-secondary/20 text-secondary', chance: 15 },     // Defense
                { type: 'government', label: '◆', color: 'bg-warning/20 text-warning', chance: 15 },      // Government
                { type: 'conflict', label: '✕', color: 'bg-danger/20 text-danger', chance: 10 },          // Conflict
                { type: 'breakthrough', label: '★', color: 'bg-purple-500/20 text-purple-400', chance: 10 } // Breakthrough
            ];

            // Cloud Function Interface (auto-select local or online)
            const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const EVOLVE_ENDPOINT = isLocal
                ? 'http://localhost:5001/chat-294cc/us-central1/evolve'
                : 'https://us-central1-chat-294cc.cloudfunctions.net/evolve';

            // 敌方/本地覆盖层与画布缓存
            let localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
            let lastAIOverlays = null;
            let localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
            let lastAIEnemyOverlays = null;
            let localFieldCanvas = null;
            let localEnemyFieldCanvas = null;
            const FIELD_CANVAS_COLS = 96;
            const FIELD_CANVAS_ROWS = 48;
            const FIELD_CHARSETS = {
                settlement: [' ', '.', 'o', 'O'],
                technology: [' ', '.', '+', '*'],
                defense: [' ', '.', '+', '#'],
                government: [' ', '.', '-', 'H'],
                conflict: [' ', '.', 'x', 'X'],
                breakthrough: [' ', '.', '*', '*']
            };
            const FIELD_SIGMA = {
                settlement: 9,
                technology: 10,
                defense: 7,
                government: 9,
                conflict: 12,
                breakthrough: 9
            };
            // 持续演化视觉循环参数
            let visualPhase = 0;
            let visualLoopHandle = null;
            const VISUAL_INTERVAL_MS = 80;
            const DRIFT_AMPLITUDE = 1.5; // 单位: 百分比坐标
            let fieldCanvasEnabled = true;
            let rowCursorLocal = 0;
            let rowCursorEnemy = 0;
            const ROWS_PER_FRAME = 6;
            let rafId = null;
            let frameParity = 0;
            // 影响强度网格（用于领地判定）
            let localInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
            let enemyInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
            
            // Event Types
            const eventTypes = [
                { 
                    type: 'positive',
                    messages: [
                        'Rich resource reserves discovered, promoting economic growth',
                        'Major technological breakthrough drives civilization progress',
                        'Peace treaty signing brings stable development environment',
                        'Agricultural innovation dramatically increases food production',
                        'Outstanding leader emerges, strengthening social cohesion',
                        'New energy source discovered',
                        'Medical advances extend average lifespan',
                        'Cultural prosperity, arts and sciences flourish together'
                    ],
                    effects: { population: 5, technology: 3, stability: 5 }
                },
                { 
                    type: 'negative',
                    messages: [
                        'Natural disaster causes major losses',
                        'Resource shortage triggers social unrest',
                        'Internal conflict weakens civilization cohesion',
                        'Disease epidemic leads to population decline',
                        'Technology stagnates, development hits bottleneck',
                        'External threats intensify tensions',
                        'Environmental degradation begins affecting survival',
                        'Economic crisis reduces living standards'
                    ],
                    effects: { population: -5, technology: -2, stability: -8 }
                },
                { 
                    type: 'neutral',
                    messages: [
                        'Important cultural celebration held',
                        'New social customs begin forming',
                        'Exploration team discovers unknown regions',
                        'New artistic movement gains popularity',
                        'Traditional knowledge compiled and preserved',
                        'Climate shows minor changes',
                        'New trade routes established',
                        'Education system undergoes reform'
                    ],
                    effects: { population: 1, technology: 1, stability: 0 }
                }
            ];
            
            // Civilization Stage Definitions
            const civilizationStages = [
                { name: 'Primitive', minTech: 0, maxTech: 20, color: '#00B42A' },
                { name: 'Agricultural', minTech: 20, maxTech: 40, color: '#722ED1' },
                { name: 'Industrial', minTech: 40, maxTech: 60, color: '#FF7D00' },
                { name: 'Information', minTech: 60, maxTech: 80, color: '#165DFF' },
                { name: 'Space Age', minTech: 80, maxTech: 100, color: '#86909C' }
            ];
            
            // Lifecycle Stages
            const lifeStages = [
                { name: 'Birth', range: [0, 0.1] },
                { name: 'Growth', range: [0.1, 0.4] },
                { name: 'Prosperity', range: [0.4, 0.7] },
                { name: 'Decline', range: [0.7, 0.9] },
                { name: 'Terminal', range: [0.9, 1.0] }
            ];
            
            // 初始化
            function initialize() {
                // 重置文明状态
                civilization = {
                    population: 10,
                    technology: 0,
                    stability: 50,
                    resources: 50,
                    environment: 50,
                    economy: 50,
                    culture: 50,
                    military: 50,
                    happiness: 50,
                    diplomacy: 50,
                    settlements: [],
                    events: [],
                    stage: 0,
                    lifespan: Math.floor(Math.random() * 3000) + 2000, // 5-15年左右
                    isDeclining: false,
                    lastEventDay: 0
                };
                
                // 重置时间
                day = 0;
                year = 0;
                totalDays = 0;
                
                // 清空符号和事件
                civilizationSymbols.innerHTML = '';
                eventLogEl.innerHTML = '<p class="text-gray-400 italic">Civilization development events will appear after simulation starts...</p>';
                // 清空抽象覆盖层
                localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                lastAIOverlays = null;
                localFieldCanvas = null;
                // 敌方初始化
                enemy = {
                    population: 8,
                    technology: 0,
                    stability: 50,
                    resources: 50,
                    environment: 50,
                    economy: 50,
                    culture: 50,
                    military: 55,
                    happiness: 45,
                    diplomacy: 30,
                    settlements: [],
                    stage: 0,
                    isDeclining: false
                };
                localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                lastAIEnemyOverlays = null;
                localEnemyFieldCanvas = null;
                renderMergedOverlays(null);
                renderMergedEnemyOverlays(null);
                const asciiCanvas = document.getElementById('ascii-canvas');
                if (asciiCanvas) asciiCanvas.textContent = '';
                const asciiCanvasEnemy = document.getElementById('ascii-canvas-enemy');
                if (asciiCanvasEnemy) asciiCanvasEnemy.textContent = '';
                // 重置并启动视觉循环
                stopVisualLoop();
                startVisualLoop();
                
                // 更新UI
                updateUI();
                
                // 显示加载状态
                loadingOverlay.classList.remove('hidden');
                
                // 模拟初始化过程
                setTimeout(() => {
                    // 创建初始定居点
                    addSymbol('settlement', 50, 50);
                    addEnemySymbol('settlement', 72, 52);
                    addEvent('neutral', 'A civilization is born on this land');
                    
                    // 隐藏加载状态
                    loadingOverlay.classList.add('hidden');
                }, 1500);
            }
            
            // 更新UI显示
            function updateUI() {
                // 更新时间显示
                simulationTimeEl.textContent = `${year}Y ${day}D`;
                
                // 更新文明属性
                populationEl.textContent = formatNumber(civilization.population);
                technologyEl.textContent = Math.round(civilization.technology);
                stabilityEl.textContent = `${Math.round(civilization.stability)}%`;
                document.getElementById('resources').textContent = Math.round(civilization.resources);
                document.getElementById('environment').textContent = Math.round(civilization.environment);
                document.getElementById('economy').textContent = Math.round(civilization.economy);
                document.getElementById('culture').textContent = Math.round(civilization.culture);
                document.getElementById('military').textContent = Math.round(civilization.military);
                document.getElementById('happiness').textContent = Math.round(civilization.happiness);
                document.getElementById('diplomacy').textContent = Math.round(civilization.diplomacy);
                
                // 更新文明阶段
                updateCivilizationStage();
                updateAsciiStageBar();
                
                // 更新生命周期
                updateLifespanProgress();
                // 更新 HUD
                updateLiveHUD();
            }

            // 添加不影响数值的叙事事件
            function addNarrativeEvent(eventType, message) {
                const eventEl = document.createElement('pre');
                eventEl.className = 'font-mono text-xs p-2 rounded-lg bg-gray-800/60 text-gray-300 whitespace-pre-wrap';
                const prefix = eventType === 'positive' ? '[+]' : eventType === 'negative' ? '[-]' : '[*]';
                eventEl.textContent = `${prefix} Y${year}D${day} | ${message}`;
                if (eventLogEl.firstChild) {
                    eventLogEl.insertBefore(eventEl, eventLogEl.firstChild);
                } else {
                    eventLogEl.appendChild(eventEl);
                }
                eventLogEl.scrollTop = 0;
                civilization.events.push({ day: totalDays, type: eventType, message });
                civilization.lastEventDay = totalDays;
            }

            function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

            function applyAIDelta(result) {
                if (!result || !result.stateDelta) return;
                const d = result.stateDelta;
                if (typeof d.populationDelta === 'number') {
                    civilization.population = Math.max(1, civilization.population + d.populationDelta);
                }
                if (typeof d.technologyDelta === 'number') {
                    civilization.technology = clamp(civilization.technology + d.technologyDelta, 0, 100);
                }
                if (typeof d.stabilityDelta === 'number') {
                    civilization.stability = clamp(civilization.stability + d.stabilityDelta, 0, 100);
                }
                if (typeof d.resourcesDelta === 'number') {
                    civilization.resources = clamp(civilization.resources + d.resourcesDelta, 0, 100);
                }
                if (typeof d.environmentDelta === 'number') {
                    civilization.environment = clamp(civilization.environment + d.environmentDelta, 0, 100);
                }
                if (typeof d.economyDelta === 'number') {
                    civilization.economy = clamp(civilization.economy + d.economyDelta, 0, 100);
                }
                if (typeof d.cultureDelta === 'number') {
                    civilization.culture = clamp(civilization.culture + d.cultureDelta, 0, 100);
                }
                if (typeof d.militaryDelta === 'number') {
                    civilization.military = clamp(civilization.military + d.militaryDelta, 0, 100);
                }
                if (typeof d.happinessDelta === 'number') {
                    civilization.happiness = clamp(civilization.happiness + d.happinessDelta, 0, 100);
                }
                if (typeof d.diplomacyDelta === 'number') {
                    civilization.diplomacy = clamp(civilization.diplomacy + d.diplomacyDelta, 0, 100);
                }
                if (typeof d.isDeclining === 'boolean') {
                    civilization.isDeclining = d.isDeclining;
                }
                if (Array.isArray(result.symbols)) {
                    result.symbols.slice(0, 3).forEach(s => {
                        if (!s || !s.type || typeof s.x !== 'number' || typeof s.y !== 'number') return;
                        const t = ['settlement','technology','defense','government','conflict','breakthrough'].includes(s.type) ? s.type : 'settlement';
                        const x = clamp(s.x, 10, 90);
                        const y = clamp(s.y, 10, 90);
                        addSymbol(t, x, y, !!s.isLarge);
                    });
                }
                // 敌方增量与符号
                if (result.enemyDelta) {
                    const d2 = result.enemyDelta;
                    if (typeof d2.populationDelta === 'number') enemy.population = Math.max(1, enemy.population + d2.populationDelta);
                    if (typeof d2.technologyDelta === 'number') enemy.technology = clamp(enemy.technology + d2.technologyDelta, 0, 100);
                    if (typeof d2.stabilityDelta === 'number') enemy.stability = clamp(enemy.stability + d2.stabilityDelta, 0, 100);
                    if (typeof d2.resourcesDelta === 'number') enemy.resources = clamp(enemy.resources + d2.resourcesDelta, 0, 100);
                    if (typeof d2.environmentDelta === 'number') enemy.environment = clamp(enemy.environment + d2.environmentDelta, 0, 100);
                    if (typeof d2.economyDelta === 'number') enemy.economy = clamp(enemy.economy + d2.economyDelta, 0, 100);
                    if (typeof d2.cultureDelta === 'number') enemy.culture = clamp(enemy.culture + d2.cultureDelta, 0, 100);
                    if (typeof d2.militaryDelta === 'number') enemy.military = clamp(enemy.military + d2.militaryDelta, 0, 100);
                    if (typeof d2.happinessDelta === 'number') enemy.happiness = clamp(enemy.happiness + d2.happinessDelta, 0, 100);
                    if (typeof d2.diplomacyDelta === 'number') enemy.diplomacy = clamp(enemy.diplomacy + d2.diplomacyDelta, 0, 100);
                    if (typeof d2.isDeclining === 'boolean') enemy.isDeclining = d2.isDeclining;
                }
                if (Array.isArray(result.enemySymbols)) {
                    result.enemySymbols.slice(0, 3).forEach(s => {
                        if (!s || !s.type || typeof s.x !== 'number' || typeof s.y !== 'number') return;
                        const t = ['settlement','technology','defense','government','conflict','breakthrough'].includes(s.type) ? s.type : 'settlement';
                        const x = clamp(s.x, 10, 90);
                        const y = clamp(s.y, 10, 90);
                        addEnemySymbol(t, x, y, !!s.isLarge);
                    });
                }
                if (Array.isArray(result.events)) {
                    result.events.slice(0, 4).forEach(ev => {
                        const t = ev?.type === 'positive' || ev?.type === 'negative' ? ev.type : 'neutral';
                        addNarrativeEvent(t, ev?.message || 'AI-generated event');
                    });
                }
                if (result.battle && result.battle.summary) {
                    addNarrativeEvent('neutral', `Battle Report: ${result.battle.summary}`);
                }
                // 计算 AI 心情（基于正负事件占比与稳定性）
                try {
                    const recent = (result.events || []).slice(0, 4);
                    const positive = recent.filter(e => e?.type === 'positive').length;
                    const negative = recent.filter(e => e?.type === 'negative').length;
                    const moodScore = clamp(50 + (positive - negative) * 10 + (civilization.stability - 50) * 0.2, 0, 100);
                    updateAIMood(moodScore);
                } catch {}

                // 绘制 ASCII 覆盖层
                try {
                    if (result.overlays) { lastAIOverlays = result.overlays; }
                    renderMergedOverlays(lastAIOverlays);
                } catch {}
                // 敌方覆盖层
                try {
                    if (result.enemyOverlays) { lastAIEnemyOverlays = result.enemyOverlays; }
                    renderMergedEnemyOverlays(lastAIEnemyOverlays);
                } catch {}
                // 渲染整帧 ASCII 画布
                try {
                    renderAsciiCanvasMerged();
                    renderEnemyAsciiCanvasMerged();
                } catch {}
            }

            function percentToPxX(p) { return (p / 100) * simulationArea.clientWidth; }
            function percentToPxY(p) { return (p / 100) * simulationArea.clientHeight; }

            function renderAsciiOverlays(overlays) {
                const layer = document.getElementById('ascii-overlays');
                if (!layer) return;
                layer.innerHTML = '';
                const ns = 'http://www.w3.org/2000/svg';
                // 用 SVG 便于画线，但只渲染 ASCII 字符
                const svg = document.createElementNS(ns, 'svg');
                svg.setAttribute('class', 'absolute inset-0 w-full h-full');
                svg.setAttribute('viewBox', `0 0 ${simulationArea.clientWidth} ${simulationArea.clientHeight}`);

                // routes: 用小文字连续铺设字符
                (overlays.routes || []).slice(0, 3).forEach(r => {
                    const [x1,y1] = r.from || [10,10];
                    const [x2,y2] = r.to || [90,90];
                    const ch = r.char || '-';
                    const steps = 18;
                    for (let i=0;i<=steps;i++) {
                        const t = i/steps;
                        const x = percentToPxX(x1 + (x2 - x1)*t);
                        const y = percentToPxY(y1 + (y2 - y1)*t);
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y);
                        text.setAttribute('fill', '#15803d');
                        text.setAttribute('font-size', '9');
                        text.textContent = ch;
                        svg.appendChild(text);
                    }
                });

                // regions: 圆环点阵
                (overlays.regions || []).slice(0, 4).forEach(g => {
                    const [cx,cy] = g.center || [50,50];
                    const r = Math.max(5, Math.min(16, g.radius || 8));
                    const ch = g.char || '*';
                    const dots = r * 7;
                    for (let i=0;i<dots;i++) {
                        const a = (i/dots) * 2*Math.PI;
                        const x = percentToPxX(cx + Math.cos(a)*r);
                        const y = percentToPxY(cy + Math.sin(a)*r);
                        const t = document.createElementNS(ns, 'text');
                        t.setAttribute('x', x);
                        t.setAttribute('y', y);
                        t.setAttribute('fill', '#15803d');
                        t.setAttribute('font-size', '9');
                        t.textContent = ch;
                        svg.appendChild(t);
                    }
                });

                // labels
                (overlays.labels || []).slice(0, 3).forEach(l => {
                    const [lx,ly] = l.at || [50,50];
                    const t = document.createElementNS(ns, 'text');
                    t.setAttribute('x', percentToPxX(lx));
                    t.setAttribute('y', percentToPxY(ly));
                    t.setAttribute('fill', '#16a34a');
                    t.setAttribute('font-size', '10');
                    t.textContent = `[${l.text || 'LABEL'}]`;
                    svg.appendChild(t);
                });

                // structures: 简单字符方阵
                (overlays.structures || []).slice(0, 2).forEach(s => {
                    const [sx,sy] = s.at || [50,50];
                    const size = Math.max(3, Math.min(6, s.size || 4));
                    for (let i=0;i<size;i++) {
                        for (let j=0;j<size;j++) {
                            const t = document.createElementNS(ns, 'text');
                            t.setAttribute('x', percentToPxX(sx + i*0.6));
                            t.setAttribute('y', percentToPxY(sy + j*0.6));
                            t.setAttribute('fill', '#15803d');
                            t.setAttribute('font-size', '9');
                            t.textContent = s.shape === 'fort' ? '#' : s.shape === 'hub' ? '+' : '█';
                            svg.appendChild(t);
                        }
                    }
                });

                layer.appendChild(svg);
            }

            // 敌方覆盖层（红色）
            function renderAsciiOverlaysEnemy(overlays) {
                const layer = document.getElementById('ascii-overlays-enemy');
                if (!layer) return;
                layer.innerHTML = '';
                const ns = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(ns, 'svg');
                svg.setAttribute('class', 'absolute inset-0 w-full h-full');
                svg.setAttribute('viewBox', `0 0 ${simulationArea.clientWidth} ${simulationArea.clientHeight}`);
                (overlays.routes || []).slice(0, 3).forEach(r => {
                    const [x1,y1] = r.from || [10,10];
                    const [x2,y2] = r.to || [90,90];
                    const ch = r.char || '-';
                    const steps = 18;
                    for (let i=0;i<=steps;i++) {
                        const t = i/steps;
                        const x = percentToPxX(x1 + (x2 - x1)*t);
                        const y = percentToPxY(y1 + (y2 - y1)*t);
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y);
                        text.setAttribute('fill', '#dc2626');
                        text.setAttribute('font-size', '9');
                        text.textContent = ch;
                        svg.appendChild(text);
                    }
                });
                (overlays.regions || []).slice(0, 4).forEach(g => {
                    const [cx,cy] = g.center || [50,50];
                    const r = Math.max(5, Math.min(16, g.radius || 8));
                    const ch = g.char || 'x';
                    const dots = r * 7;
                    for (let i=0;i<dots;i++) {
                        const a = (i/dots) * 2*Math.PI;
                        const x = percentToPxX(cx + Math.cos(a)*r);
                        const y = percentToPxY(cy + Math.sin(a)*r);
                        const t = document.createElementNS(ns, 'text');
                        t.setAttribute('x', x);
                        t.setAttribute('y', y);
                        t.setAttribute('fill', '#ef4444');
                        t.setAttribute('font-size', '9');
                        t.textContent = ch;
                        svg.appendChild(t);
                    }
                });
                (overlays.labels || []).slice(0, 3).forEach(l => {
                    const [lx,ly] = l.at || [50,50];
                    const t = document.createElementNS(ns, 'text');
                    t.setAttribute('x', percentToPxX(lx));
                    t.setAttribute('y', percentToPxY(ly));
                    t.setAttribute('fill', '#ef4444');
                    t.setAttribute('font-size', '10');
                    t.textContent = `[${l.text || 'ENEMY'}]`;
                    svg.appendChild(t);
                });
                (overlays.structures || []).slice(0, 2).forEach(s => {
                    const [sx,sy] = s.at || [50,50];
                    const size = Math.max(3, Math.min(6, s.size || 4));
                    for (let i=0;i<size;i++) {
                        for (let j=0;j<size;j++) {
                            const t = document.createElementNS(ns, 'text');
                            t.setAttribute('x', percentToPxX(sx + i*0.6));
                            t.setAttribute('y', percentToPxY(sy + j*0.6));
                            t.setAttribute('fill', '#dc2626');
                            t.setAttribute('font-size', '9');
                            t.textContent = s.shape === 'fort' ? '#' : s.shape === 'hub' ? '+' : '█';
                            svg.appendChild(t);
                        }
                    }
                });
                layer.appendChild(svg);
            }

            // 合并并渲染 AI 覆盖层与本地抽象覆盖层
            function renderMergedOverlays(aiOverlays) {
                const effectiveAI = aiOverlays || lastAIOverlays || null;
                const merged = {
                    routes: [
                        ...((localOverlays && localOverlays.routes) || []),
                        ...((effectiveAI && effectiveAI.routes) || [])
                    ],
                    regions: [
                        ...((localOverlays && localOverlays.regions) || []),
                        ...((effectiveAI && effectiveAI.regions) || [])
                    ],
                    labels: [
                        ...((localOverlays && localOverlays.labels) || []),
                        ...((effectiveAI && effectiveAI.labels) || [])
                    ],
                    structures: [
                        ...((localOverlays && localOverlays.structures) || []),
                        ...((effectiveAI && effectiveAI.structures) || [])
                    ],
                    canvas: effectiveAI && effectiveAI.canvas ? effectiveAI.canvas : null
                };
                renderAsciiOverlays(merged);
            }

            function renderMergedEnemyOverlays(aiOverlays) {
                const effectiveAI = aiOverlays || lastAIEnemyOverlays || null;
                const merged = {
                    routes: [
                        ...((localEnemyOverlays && localEnemyOverlays.routes) || []),
                        ...((effectiveAI && effectiveAI.routes) || [])
                    ],
                    regions: [
                        ...((localEnemyOverlays && localEnemyOverlays.regions) || []),
                        ...((effectiveAI && effectiveAI.regions) || [])
                    ],
                    labels: [
                        ...((localEnemyOverlays && localEnemyOverlays.labels) || []),
                        ...((effectiveAI && effectiveAI.labels) || [])
                    ],
                    structures: [
                        ...((localEnemyOverlays && localEnemyOverlays.structures) || []),
                        ...((effectiveAI && effectiveAI.structures) || [])
                    ],
                    canvas: effectiveAI && effectiveAI.canvas ? effectiveAI.canvas : null
                };
                renderAsciiOverlaysEnemy(merged);
            }

            // 基于现有的定居/事件特征，重建本地抽象覆盖层
            function rebuildLocalOverlays() {
                localOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                const features = civilization.settlements || [];
                for (const f of features) {
                    const isLarge = !!f.isLarge;
                    switch (f.type) {
                        case 'settlement': {
                            // 更抽象：只用较小半径标记中心，主要由场域画布表现
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                            break;
                        }
                        case 'technology': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 5 : 3, shape: 'hub' });
                            break;
                        }
                        case 'defense': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'fort' });
                            break;
                        }
                        case 'government': {
                            localOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'hub' });
                            break;
                        }
                        case 'conflict': {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 12 : 9, char: 'x' });
                            break;
                        }
                        case 'breakthrough': {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 8, char: '*' });
                            break;
                        }
                        default: {
                            localOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                        }
                    }
                }
                renderMergedOverlays(null);
                updateFieldCanvas();
                renderAsciiCanvasMerged();
            }

            // 敌方抽象覆盖层
            function rebuildEnemyLocalOverlays() {
                localEnemyOverlays = { routes: [], regions: [], labels: [], structures: [], canvas: null };
                const features = enemy.settlements || [];
                for (const f of features) {
                    const isLarge = !!f.isLarge;
                    switch (f.type) {
                        case 'settlement': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: 'x' });
                            break;
                        }
                        case 'technology': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 5 : 3, shape: 'hub' });
                            break;
                        }
                        case 'defense': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'fort' });
                            break;
                        }
                        case 'government': {
                            localEnemyOverlays.structures.push({ at: [f.x, f.y], size: isLarge ? 4 : 3, shape: 'hub' });
                            break;
                        }
                        case 'conflict': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 12 : 9, char: 'x' });
                            break;
                        }
                        case 'breakthrough': {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 8, char: '*' });
                            break;
                        }
                        default: {
                            localEnemyOverlays.regions.push({ center: [f.x, f.y], radius: isLarge ? 10 : 7, char: '.' });
                        }
                    }
                }
                renderMergedEnemyOverlays(null);
                updateEnemyFieldCanvas();
                renderEnemyAsciiCanvasMerged();
            }

            // 生成本地场域 ASCII 画布
            function generateLocalFieldCanvas(cols = FIELD_CANVAS_COLS, rows = FIELD_CANVAS_ROWS) {
                const features = civilization.settlements || [];
                const grid = new Array(rows);
                for (let j = 0; j < rows; j++) {
                    let rowChars = '';
                    const y = (j + 0.5) / rows * 100;
                    for (let i = 0; i < cols; i++) {
                        const x = (i + 0.5) / cols * 100;
                        let chInt = {
                            settlement: 0,
                            technology: 0,
                            defense: 0,
                            government: 0,
                            conflict: 0,
                            breakthrough: 0
                        };
                        for (const f of features) {
                            // 仅用于渲染的微漂移，不改变真实数据
                            const seed = (f.id % 1000) / 1000;
                            const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const fx = f.x + Math.sin(visualPhase * 1.3 + seed * 6.283) * ampX;
                            const fy = f.y + Math.cos(visualPhase * 1.1 + seed * 6.283) * ampY;
                            const dx = x - fx;
                            const dy = y - fy;
                            const d2 = dx*dx + dy*dy;
                            const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                            const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                            const val = Math.exp(-d2 / (2 * sigma * sigma));
                            chInt[type] += val;
                        }
                        // 轻微的时空闪烁，增加持续演化感
                        const shimmer = 1 + 0.08 * Math.sin(visualPhase * 4 + i * 0.21 + j * 0.37);
                        for (const k in chInt) { chInt[k] *= shimmer; }
                        // 选取主导通道
                        let maxType = 'settlement';
                        let maxVal = -1;
                        for (const k in chInt) {
                            if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; }
                        }
                        // 阈值: 过低则留空
                        if (maxVal < 0.12) {
                            rowChars += ' ';
                        } else {
                            const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                            const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                            rowChars += cs[level];
                        }
                    }
                    grid[j] = rowChars;
                }
                return { grid };
            }

            function updateFieldCanvas() {
                if (!fieldCanvasEnabled) { localFieldCanvas = null; return; }
                localFieldCanvas = generateLocalFieldCanvas();
            }

            function generateLocalEnemyFieldCanvas(cols = FIELD_CANVAS_COLS, rows = FIELD_CANVAS_ROWS) {
                const features = enemy.settlements || [];
                const grid = new Array(rows);
                for (let j = 0; j < rows; j++) {
                    let rowChars = '';
                    const y = (j + 0.5) / rows * 100;
                    for (let i = 0; i < cols; i++) {
                        const x = (i + 0.5) / cols * 100;
                        let chInt = { settlement: 0, technology: 0, defense: 0, government: 0, conflict: 0, breakthrough: 0 };
                        for (const f of features) {
                            const seed = (f.id % 1000) / 1000;
                            const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                            const fx = f.x + Math.sin(visualPhase * 1.25 + seed * 6.283) * ampX;
                            const fy = f.y + Math.cos(visualPhase * 1.18 + seed * 6.283) * ampY;
                            const dx = x - fx;
                            const dy = y - fy;
                            const d2 = dx*dx + dy*dy;
                            const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                            const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                            const val = Math.exp(-d2 / (2 * sigma * sigma));
                            chInt[type] += val;
                        }
                        const shimmer = 1 + 0.08 * Math.cos(visualPhase * 4.3 + i * 0.19 + j * 0.41);
                        for (const k in chInt) { chInt[k] *= shimmer; }
                        let maxType = 'settlement';
                        let maxVal = -1;
                        for (const k in chInt) { if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; } }
                        if (maxVal < 0.12) { rowChars += ' '; }
                        else {
                            const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                            const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                            rowChars += cs[level];
                        }
                    }
                    grid[j] = rowChars;
                }
                return { grid };
            }

            function updateEnemyFieldCanvas() {
                if (!fieldCanvasEnabled) { localEnemyFieldCanvas = null; return; }
                localEnemyFieldCanvas = generateLocalEnemyFieldCanvas();
            }

            // 合并 AI 与本地场域画布并渲染
            function renderAsciiCanvasMerged() {
                const canvas = document.getElementById('ascii-canvas');
                if (!canvas) return;
                if (!localFieldCanvas && fieldCanvasEnabled) updateFieldCanvas();
                // 优先使用后端权威画布（已由订阅写入 lastAIOverlays.canvas）
                const aiGrid = (lastAIOverlays && lastAIOverlays.canvas && Array.isArray(lastAIOverlays.canvas.grid))
                    ? lastAIOverlays.canvas.grid
                    : null;
                const localGrid = localFieldCanvas ? localFieldCanvas.grid : null;
                let output = [];
                if (localGrid && aiGrid) {
                    const rows = Math.min(localGrid.length, aiGrid.length);
                    for (let j = 0; j < rows; j++) {
                        const a = typeof aiGrid[j] === 'string' ? aiGrid[j] : '';
                        const b = localGrid[j] || '';
                        const cols = Math.min(a.length, b.length);
                        let merged = '';
                        for (let i = 0; i < cols; i++) {
                            const ca = a[i];
                            const cb = b[i];
                            merged += (ca && ca !== ' ') ? ca : cb;
                        }
                        output.push(merged);
                    }
                } else if (aiGrid) {
                    output = aiGrid.slice(0, FIELD_CANVAS_ROWS).map(r => (typeof r === 'string' ? r : ''));
                } else if (localGrid) {
                    output = localGrid;
                } else {
                    output = [];
                }
                canvas.textContent = output.slice(0, FIELD_CANVAS_ROWS).join('\n');
            }

            function renderEnemyAsciiCanvasMerged() {
                const canvas = document.getElementById('ascii-canvas-enemy');
                if (!canvas) return;
                if (!localEnemyFieldCanvas && fieldCanvasEnabled) updateEnemyFieldCanvas();
                const aiGrid = (lastAIEnemyOverlays && lastAIEnemyOverlays.canvas && Array.isArray(lastAIEnemyOverlays.canvas.grid))
                    ? lastAIEnemyOverlays.canvas.grid
                    : null;
                const localGrid = localEnemyFieldCanvas ? localEnemyFieldCanvas.grid : null;
                let output = [];
                if (localGrid && aiGrid) {
                    const rows = Math.min(localGrid.length, aiGrid.length);
                    for (let j = 0; j < rows; j++) {
                        const a = typeof aiGrid[j] === 'string' ? aiGrid[j] : '';
                        const b = localGrid[j] || '';
                        const cols = Math.min(a.length, b.length);
                        let merged = '';
                        for (let i = 0; i < cols; i++) {
                            const ca = a[i];
                            const cb = b[i];
                            merged += (ca && ca !== ' ') ? ca : cb;
                        }
                        output.push(merged);
                    }
                } else if (aiGrid) {
                    output = aiGrid.slice(0, FIELD_CANVAS_ROWS).map(r => (typeof r === 'string' ? r : ''));
                } else if (localGrid) {
                    output = localGrid;
                } else { output = []; }
                canvas.textContent = output.slice(0, FIELD_CANVAS_ROWS).join('\n');
                // PIP 显示我方主画面缩略
                try {
                    const pip = document.getElementById('pip-canvas');
                    const main = document.getElementById('ascii-canvas')?.textContent || '';
                    if (pip && main) {
                        const lines = main.split('\n').slice(0, 28).map(l=>l.slice(0, 70));
                        pip.textContent = lines.join('\n');
                    }
                } catch {}
            }

            // Live HUD 更新
            function pad(n){ return String(n).padStart(2,'0'); }
            function updateLiveHUD(){
                try {
                    const t = (year*365 + day);
                    const hh = pad(Math.floor((t%1440)/60));
                    const mm = pad(t%60);
                    const ss = pad(Math.floor((performance.now()/1000)%60));
                    const clock = document.getElementById('hud-clock');
                    if(clock) clock.textContent = `LIVE ${hh}:${mm}:${ss}`;
                    const viewers = Math.max(1, Math.floor(civilization.population/20 + Math.random()*100));
                    const viewEl = document.getElementById('hud-viewers');
                    if(viewEl) viewEl.textContent = `${viewers} viewers`;
                    const ticker = document.getElementById('hud-ticker');
                    if(ticker){
                        const last = (civilization.events||[]).slice(-3).reverse().map(e=>`${e.type==='positive'?'+':e.type==='negative'?'-':'*'} ${e.message}`).join('  |  ');
                        ticker.textContent = last || 'AI Live · 正在连接…';
                    }
                    // 机位 & 时间码
                    const cam = document.getElementById('hud-cam'); if (cam) cam.textContent = `CAM ${1 + (civilization.stage||0)}`;
                    const tc = document.getElementById('hud-tc'); if (tc) tc.textContent = `TC ${hh}:${mm}:${ss}:00`;
                    // 电量
                    const battPct = Math.max(5, 100 - Math.floor((totalDays%600)/6));
                    const battFill = document.getElementById('hud-batt-fill'); if (battFill) battFill.style.width = `${battPct}%`;
                    const battText = document.getElementById('hud-batt-pct'); if (battText) battText.textContent = `${battPct}%`;
                    // 信号强度
                    const level = 1 + ((Math.floor(performance.now()/2000) + (civilization.stage||0)) % 5);
                    for (let i=1;i<=5;i++) {
                        const bar = document.getElementById(`sig${i}`);
                        if (bar) bar.classList.toggle('sig-on', i<=level);
                    }
                } catch {}
            }

            // 简易弹幕：从事件流随机挑选并播发
            // 弹幕计时器已关闭

            function updateAIMood(score) {
                const face = score > 70 ? ':)' : score < 30 ? ':(' : ':|';
                const label = score > 70 ? 'Optimistic' : score < 30 ? 'Cautious' : 'Stable';
                const total = 14; // 进度格数
                const filled = Math.round((score / 100) * total);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(total - filled)}] ${Math.round(score)}%`;
                const faceEl = document.getElementById('ai-mood-face');
                const labelEl = document.getElementById('ai-mood-label');
                const barEl = document.getElementById('ai-mood-bar');
                if (faceEl) faceEl.textContent = face;
                if (labelEl) labelEl.textContent = label;
                if (barEl) barEl.textContent = bar;
            }

            // Generate Mock AI Response
            function generateMockAIResponse() {
                const positiveEvents = [
                    'Technological breakthrough leads to productivity leap',
                    'Diplomatic mission successfully establishes trade alliance',
                    'Agricultural reform dramatically increases food production',
                    'Cultural renaissance movement boosts social morale',
                    'Discovery of new energy source transforms industry',
                    'Education reform cultivates talented workforce',
                    'Medical breakthrough extends population lifespan',
                    'Infrastructure development strengthens regional connections'
                ];
                const negativeEvents = [
                    'Resource depletion triggers economic crisis',
                    'Environmental pollution begins affecting public health',
                    'Social tensions escalate leading to unrest',
                    'External threats become increasingly severe',
                    'Corruption weakens government credibility',
                    'Natural disaster causes major losses',
                    'Technological development stagnates',
                    'Trade friction damages economic interests'
                ];
                const neutralEvents = [
                    'Grand cultural celebration held',
                    'New philosophical movement begins spreading',
                    'Expedition discovers unknown territories',
                    'Artists create stunning masterpieces',
                    'Historical documents systematically archived',
                    'Climate patterns show subtle changes',
                    'New trade routes opened',
                    'Social customs undergo gradual transformation'
                ];

                // 根据当前状态生成变化
                const stabilityFactor = (civilization.stability - 50) / 50;
                const techFactor = civilization.technology / 100;
                const isDeclining = civilization.isDeclining;

                // 生成状态变化
                const stateDelta = {
                    populationDelta: Math.floor((Math.random() - 0.3) * 10 + stabilityFactor * 5),
                    technologyDelta: Math.floor((Math.random() - 0.2) * 3 + techFactor * 2),
                    stabilityDelta: Math.floor((Math.random() - 0.4) * 8 + (isDeclining ? -3 : 1)),
                    resourcesDelta: Math.floor((Math.random() - 0.5) * 5),
                    environmentDelta: Math.floor((Math.random() - 0.4) * 4 - techFactor * 2),
                    economyDelta: Math.floor((Math.random() - 0.3) * 6 + stabilityFactor * 3),
                    cultureDelta: Math.floor((Math.random() - 0.2) * 4),
                    militaryDelta: Math.floor((Math.random() - 0.4) * 5),
                    happinessDelta: Math.floor((Math.random() - 0.3) * 6 + stabilityFactor * 2),
                    diplomacyDelta: Math.floor((Math.random() - 0.4) * 4),
                    isDeclining: civilization.isDeclining || (Math.random() < 0.05)
                };

                // 生成事件
                const events = [];
                const numEvents = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < numEvents; i++) {
                    const rand = Math.random();
                    let type, message;
                    if (rand < 0.35) {
                        type = 'positive';
                        message = positiveEvents[Math.floor(Math.random() * positiveEvents.length)];
                    } else if (rand < 0.7) {
                        type = 'negative';
                        message = negativeEvents[Math.floor(Math.random() * negativeEvents.length)];
                    } else {
                        type = 'neutral';
                        message = neutralEvents[Math.floor(Math.random() * neutralEvents.length)];
                    }
                    events.push({ type, message });
                }

                // 生成符号
                const symbols = [];
                const numSymbols = Math.floor(Math.random() * 3) + 1;
                const symbolTypes = ['settlement', 'technology', 'defense', 'government', 'conflict', 'breakthrough'];
                for (let i = 0; i < numSymbols; i++) {
                    symbols.push({
                        type: symbolTypes[Math.floor(Math.random() * symbolTypes.length)],
                        x: Math.random() * 80 + 10,
                        y: Math.random() * 80 + 10,
                        isLarge: Math.random() < 0.3
                    });
                }

                // 生成敌方变化
                const enemyDelta = {
                    populationDelta: Math.floor((Math.random() - 0.35) * 8),
                    technologyDelta: Math.floor((Math.random() - 0.25) * 3),
                    stabilityDelta: Math.floor((Math.random() - 0.45) * 7),
                    resourcesDelta: Math.floor((Math.random() - 0.5) * 5),
                    environmentDelta: Math.floor((Math.random() - 0.4) * 4),
                    economyDelta: Math.floor((Math.random() - 0.35) * 5),
                    cultureDelta: Math.floor((Math.random() - 0.3) * 4),
                    militaryDelta: Math.floor((Math.random() - 0.3) * 6),
                    happinessDelta: Math.floor((Math.random() - 0.4) * 5),
                    diplomacyDelta: Math.floor((Math.random() - 0.5) * 4),
                    isDeclining: enemy.isDeclining || (Math.random() < 0.04)
                };

                const enemySymbols = [];
                for (let i = 0; i < 2; i++) {
                    enemySymbols.push({
                        type: symbolTypes[Math.floor(Math.random() * symbolTypes.length)],
                        x: Math.random() * 80 + 10,
                        y: Math.random() * 80 + 10,
                        isLarge: Math.random() < 0.25
                    });
                }

                // Battle Reports
                const battleSummaries = [
                    'Small-scale conflict at border, both sides suffer casualties',
                    'Diplomatic negotiations progress, tensions ease',
                    'Military exercises demonstrate power of both sides',
                    'Resource conflict continues at border regions',
                    'Cultural exchange improves mutual understanding',
                    'Trade brings benefits to both sides'
                ];

                return {
                    stateDelta,
                    events,
                    symbols,
                    enemyDelta,
                    enemySymbols,
                    battle: {
                        summary: battleSummaries[Math.floor(Math.random() * battleSummaries.length)]
                    },
                    overlays: {
                        routes: [],
                        regions: [],
                        labels: [],
                        structures: []
                    },
                    enemyOverlays: {
                        routes: [],
                        regions: [],
                        labels: [],
                        structures: []
                    }
                };
            }

            async function triggerAI() {
                if (aiPending) return;
                aiPending = true;
                document.getElementById('ai-status').classList.remove('hidden');
                try {
                    const lastEvents = civilization.events.slice(-10);
                    const payload = { state: {
                        day, year, totalDays,
                        population: civilization.population,
                        technology: civilization.technology,
                        stability: civilization.stability,
                        resources: civilization.resources,
                        environment: civilization.environment,
                        economy: civilization.economy,
                        culture: civilization.culture,
                        military: civilization.military,
                        happiness: civilization.happiness,
                        diplomacy: civilization.diplomacy,
                        isDeclining: civilization.isDeclining,
                        stage: civilization.stage
                    }, lastEvents, promptOverrides: { mode, guidelines } };
                    
                    let data;
                    try {
                        const resp = await fetch(EVOLVE_ENDPOINT, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            mode: 'cors'
                        });
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        data = await resp.json();
                    } catch (fetchError) {
                        // 后端连接失败，使用模拟数据
                        console.log('Using mock AI data (backend temporarily unavailable)');
                        data = generateMockAIResponse();
                    }
                    
                    applyAIDelta(data);
                    updateUI();
                } catch (e) {
                    console.error('AI Evolution Error:', e);
                    // 即使出错也使用模拟数据
                    const mockData = generateMockAIResponse();
                    applyAIDelta(mockData);
                    updateUI();
                } finally {
                    aiPending = false;
                    document.getElementById('ai-status').classList.add('hidden');
                }
            }
            
            // 更新文明阶段
            function updateCivilizationStage() {
                // 确定当前阶段
                let newStage = 0;
                for (let i = 0; i < civilizationStages.length; i++) {
                    if (civilization.technology >= civilizationStages[i].minTech && 
                        civilization.technology < civilizationStages[i].maxTech) {
                        newStage = i;
                        break;
                    } else if (civilization.technology >= 100) {
                        newStage = civilizationStages.length - 1;
                        break;
                    }
                }
                
                // 如果阶段变化，记录事件
                if (newStage !== civilization.stage) {
                    civilization.stage = newStage;
                    addEvent('positive', `Civilization enters ${civilizationStages[newStage].name} Age`);
                    
                    // 改变进度条颜色
                    if (civilizationStageEl) {
                    civilizationStageEl.style.backgroundColor = civilizationStages[newStage].color;
                    }
                }
                
                // 更新进度条（若存在 DOM 元素）
                let stageProgress = 0;
                if (civilization.technology < 20) {
                    stageProgress = civilization.technology / 20 * 20;
                } else if (civilization.technology < 40) {
                    stageProgress = 20 + (civilization.technology - 20) / 20 * 20;
                } else if (civilization.technology < 60) {
                    stageProgress = 40 + (civilization.technology - 40) / 20 * 20;
                } else if (civilization.technology < 80) {
                    stageProgress = 60 + (civilization.technology - 60) / 20 * 20;
                } else if (civilization.technology < 100) {
                    stageProgress = 80 + (civilization.technology - 80) / 20 * 20;
                } else {
                    stageProgress = 100;
                }
                
                if (civilizationStageEl) {
                    civilizationStageEl.style.width = `${stageProgress}%`;
                }
            }

            // ASCII 风格阶段条
            function updateAsciiStageBar() {
                const totalBlocks = 30;
                const percent = Math.min(100, Math.max(0, civilization.technology));
                const filled = Math.round((percent / 100) * totalBlocks);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(totalBlocks - filled)}] ${Math.round(percent)}%`;
                const label = ['Pri','Agr','Ind','Inf','Spa'][civilization.stage] || '';
                const el = document.getElementById('ascii-stage-bar');
                if (el) el.textContent = `${bar} <${label}>`;
            }
            
            // 更新生命周期进度
            function updateLifespanProgress() {
                const percentage = Math.min(100, (totalDays / civilization.lifespan) * 100);
                lifespanPercentage.textContent = `${Math.round(percentage)}%`;
                const totalBlocks = 30;
                const filled = Math.round((percentage / 100) * totalBlocks);
                const bar = `[${'#'.repeat(filled)}${'.'.repeat(totalBlocks - filled)}] ${Math.round(percentage)}%`;
                const el = document.getElementById('lifespan-ascii');
                if (el) el.textContent = bar;
                
                // 确定生命周期阶段
                let currentStage = '';
                for (let stage of lifeStages) {
                    if (percentage / 100 >= stage.range[0] && percentage / 100 < stage.range[1]) {
                        currentStage = stage.name;
                        break;
                    }
                }
                lifeStageEl.textContent = `Current Stage: ${currentStage}`;
                
                // 检查是否进入衰退期
                if (percentage > 70 && !civilization.isDeclining) {
                    civilization.isDeclining = true;
                    addEvent('negative', 'Civilization begins showing signs of decline');
                }
                
                // 检查文明是否终结
                if (percentage >= 100) {
                    addEvent('negative', 'Civilization has reached the end of its history');
                    pauseSimulation();
                    
                    // 添加一个终结符号
                    addSymbol('conflict', 50, 50, true);
                }
            }
            
            // 添加文明符号
            function addSymbol(type, x, y, isLarge = false) {
                // 仅记录抽象特征，后续用覆盖层渲染大范围符号
                const symbolType = symbolTypes.find(st => st.type === type);
                if (!symbolType) return;
                civilization.settlements.push({
                    id: Date.now(),
                    type,
                    x,
                    y,
                    isLarge: !!isLarge,
                    age: 0
                });
                rebuildLocalOverlays();
            }

            function addEnemySymbol(type, x, y, isLarge = false) {
                const symbolType = symbolTypes.find(st => st.type === type);
                if (!symbolType) return;
                enemy.settlements.push({
                    id: Date.now() + Math.floor(Math.random()*1000),
                    type,
                    x,
                    y,
                    isLarge: !!isLarge,
                    age: 0
                });
                rebuildEnemyLocalOverlays();
            }
            
            // 随机添加符号
            function addRandomSymbol() {
                // 随机选择符号类型
                let random = Math.random() * 100;
                let selectedType = null;
                
                for (let type of symbolTypes) {
                    random -= type.chance;
                    if (random <= 0) {
                        selectedType = type.type;
                        break;
                    }
                }
                
                // 随机位置
                const x = Math.random() * 80 + 10; // 10-90%
                const y = Math.random() * 80 + 10; // 10-90%
                
                // 添加符号
                addSymbol(selectedType, x, y);
            }
            
            // 更新符号状态
            function updateSymbols() {
                // 随机移除一些旧特征
                if (civilization.settlements.length > 50 && Math.random() < 0.1) {
                    let oldest = null;
                    for (const s of civilization.settlements) {
                        if (!oldest || s.age > oldest.age) oldest = s;
                    }
                    if (oldest) {
                        civilization.settlements = civilization.settlements.filter(s => s.id !== oldest.id);
                    }
                }
                // 年龄递增
                civilization.settlements.forEach(s => { s.age++; });
                // 重建抽象覆盖层
                rebuildLocalOverlays();
            }

            function updateEnemySymbols() {
                if (enemy.settlements.length > 50 && Math.random() < 0.1) {
                    let oldest = null;
                    for (const s of enemy.settlements) { if (!oldest || s.age > oldest.age) oldest = s; }
                    if (oldest) enemy.settlements = enemy.settlements.filter(s => s.id !== oldest.id);
                }
                enemy.settlements.forEach(s => { s.age++; });
                rebuildEnemyLocalOverlays();
            }
            
            // 添加事件
            function addEvent(eventType, customMessage = null) {
                // 查找事件类型
                const eventGroup = eventTypes.find(et => et.type === eventType);
                if (!eventGroup) return;
                
                // 选择消息
                const message = customMessage || eventGroup.messages[Math.floor(Math.random() * eventGroup.messages.length)];
                
                // 应用事件效果
                civilization.population = Math.max(1, civilization.population + (eventGroup.effects.population || 0));
                civilization.technology = Math.max(0, Math.min(100, civilization.technology + (eventGroup.effects.technology || 0)));
                civilization.stability = Math.max(0, Math.min(100, civilization.stability + (eventGroup.effects.stability || 0)));
                
                // 创建事件元素
                const eventEl = document.createElement('pre');
                eventEl.className = 'font-mono text-xs p-2 rounded-lg bg-gray-800/60 text-gray-300 whitespace-pre-wrap';
                const prefix = eventType === 'positive' ? '[+]' : eventType === 'negative' ? '[-]' : '[*]';
                eventEl.textContent = `${prefix} Y${year}D${day} | ${message}`;
                
                // 添加到日志顶部
                if (eventLogEl.firstChild) {
                    eventLogEl.insertBefore(eventEl, eventLogEl.firstChild);
                } else {
                    eventLogEl.appendChild(eventEl);
                }
                
                // 自动滚动到顶部
                eventLogEl.scrollTop = 0;
                
                // 记录事件
                civilization.events.push({
                    day: totalDays,
                    type: eventType,
                    message
                });
                
                // 更新最后事件日期
                civilization.lastEventDay = totalDays;
            }
            
            // 随机事件
            function randomEvent() {
                // 每7-14天发生一个事件
                const daysSinceLastEvent = totalDays - civilization.lastEventDay;
                if (daysSinceLastEvent < 7 || Math.random() > 1 / (14 - daysSinceLastEvent)) {
                    return;
                }
                
                // 基于文明稳定性调整事件概率
                let eventChance = { positive: 0.3, negative: 0.3, neutral: 0.4 };
                // 模式加权
                if (mode === 'peace') {
                    eventChance.positive += 0.15;
                    eventChance.negative -= 0.15;
                } else if (mode === 'disaster') {
                    eventChance.positive -= 0.15;
                    eventChance.negative += 0.15;
                }
                
                // 稳定性高时更可能发生积极事件
                if (civilization.stability > 70) {
                    eventChance.positive += 0.2;
                    eventChance.negative -= 0.2;
                } 
                // 稳定性低时更可能发生消极事件
                else if (civilization.stability < 30) {
                    eventChance.positive -= 0.2;
                    eventChance.negative += 0.2;
                }
                
                // 衰退期更可能发生消极事件
                if (civilization.isDeclining) {
                    eventChance.positive -= 0.1;
                    eventChance.negative += 0.1;
                }
                
                // 确保概率不为负
                eventChance.positive = Math.max(0, eventChance.positive);
                eventChance.negative = Math.max(0, eventChance.negative);
                eventChance.neutral = 1 - eventChance.positive - eventChance.negative;
                
                // 随机选择事件类型
                let random = Math.random();
                let eventType;
                
                if (random < eventChance.positive) {
                    eventType = 'positive';
                } else if (random < eventChance.positive + eventChance.negative) {
                    eventType = 'negative';
                } else {
                    eventType = 'neutral';
                }
                
                // 添加事件
                addEvent(eventType);
            }
            
            // 模拟一天的变化
            function simulateDay() {
                // 更新时间
                day++;
                totalDays++;
                if (day >= 365) {
                    day = 0;
                    year++;
                }
                
                // 移除本地自然演化，交由云端权威
                
                // 随机添加符号
                if (Math.random() < 0.1 && civilization.settlements.length < 100) {
                    addRandomSymbol();
                }
                // 敌方随机成长
                if (Math.random() < 0.08 && enemy.settlements.length < 100) {
                    const x = Math.random() * 80 + 10;
                    const y = Math.random() * 80 + 10;
                    const types = ['settlement','technology','defense','government','conflict'];
                    addEnemySymbol(types[Math.floor(Math.random()*types.length)], x, y);
                }
                
                // 更新符号状态
                updateSymbols();
                updateEnemySymbols();
                
                // 随机事件
                randomEvent();
                // 本地触发 AI（异步）
                if (aiEnabled && (totalDays % aiFrequency === 0)) {
                    setTimeout(() => { triggerAI(); }, 0);
                }
                
                // 更新UI（只读渲染依旧）
                updateUI();
            }
            
            // 开始模拟
            function startSimulation() {
                if (isRunning) return;
                
                isRunning = true;
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
                
                // 固定速度：每天10秒
                const intervalTime = 10000;
                
                simulationInterval = setInterval(simulateDay, intervalTime);
            }
            
            // 暂停模拟
            function pauseSimulation() {
                if (!isRunning) return;
                
                isRunning = false;
                clearInterval(simulationInterval);
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
            }
            
            // 切换模拟速度（已禁用，速度固定为每天10秒）
            function toggleSpeed() {
                // 功能已禁用，速度固定为每天10秒
                return;
            }

            // 切换AI
            function toggleAI() {
                aiEnabled = !aiEnabled;
                const aiText = document.getElementById('ai-toggle-text');
                aiText.textContent = aiEnabled ? 'AI Evolution ON' : 'AI Evolution OFF';
                const btn = document.getElementById('ai-toggle-btn');
                if (aiEnabled) {
                    btn.classList.remove('bg-gray-700');
                    btn.classList.add('bg-success/20');
                } else {
                    btn.classList.add('bg-gray-700');
                }
            }
            
            // 格式化大数字
            function formatNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return Math.round(num).toString();
            }
            
            // 显示关于模态框
            function showAboutModal() {}
            
            // 隐藏关于模态框
            function hideAboutModal() {}
            
            // 切换移动菜单
            function toggleMobileMenu() {
                mobileMenu.classList.toggle('hidden');
            }
            
            // 订阅云端权威状态（包含画布），用户共享同一演化
            try {
                if (window.firebase && firebase.firestore && window.__FIREBASE_CONFIG__ && window.__FIREBASE_CONFIG__.projectId) {
                    firebase.initializeApp?.(window.__FIREBASE_CONFIG__);
                    const db = firebase.firestore();
                    db.collection('sim').doc('state').onSnapshot((snap) => {
                        const s = snap?.data?.() || null; if (!s) return;
                        // 注入权威画布供 render 函数使用
                        lastAIOverlays = { ...(lastAIOverlays||{}), canvas: s.canvas || null };
                        // 同步核心数值
                        civilization.population = s.population ?? civilization.population;
                        civilization.technology = s.technology ?? civilization.technology;
                        civilization.stability = s.stability ?? civilization.stability;
                        civilization.resources = s.resources ?? civilization.resources;
                        civilization.environment = s.environment ?? civilization.environment;
                        civilization.economy = s.economy ?? civilization.economy;
                        civilization.culture = s.culture ?? civilization.culture;
                        civilization.military = s.military ?? civilization.military;
                        civilization.happiness = s.happiness ?? civilization.happiness;
                        civilization.diplomacy = s.diplomacy ?? civilization.diplomacy;
                        day = s.day ?? day; year = s.year ?? year; totalDays = s.totalDays ?? totalDays;
                        updateUI();
                    });
                    db.collection('sim').doc('enemy').onSnapshot((snap) => {
                        const e = snap?.data?.() || null; if (!e) return;
                        lastAIEnemyOverlays = { ...(lastAIEnemyOverlays||{}), canvas: e.canvas || null };
                    });
                }
            } catch {}
            
            // 事件监听器
            startBtn.addEventListener('click', startSimulation);
            pauseBtn.addEventListener('click', pauseSimulation);
            // speedBtn.addEventListener('click', toggleSpeed); // 速度已固定为每天10秒，不允许修改
            document.getElementById('ai-toggle-btn').addEventListener('click', toggleAI);
            document.getElementById('ai-frequency').addEventListener('change', (e) => {
                aiFrequency = parseInt(e.target.value || '3', 10);
            });
            document.getElementById('ai-trigger-btn').addEventListener('click', () => { triggerAI(); });
            document.getElementById('mode-select').addEventListener('change', (e) => {
                mode = e.target.value;
                addNarrativeEvent('neutral', `Mode switched to: ${mode === 'peace' ? 'Peace' : mode === 'disaster' ? 'Disaster' : 'Normal'}`);
            });
            document.getElementById('autosave-toggle').addEventListener('change', (e) => {
                autosaveEnabled = !!e.target.checked;
                if (autosaveEnabled) saveSnapshot();
            });
            document.getElementById('guidelines-input').addEventListener('input', (e) => {
                guidelines = e.target.value || '';
                if (autosaveEnabled) saveSnapshot();
            });
            resetBtn.addEventListener('click', async () => {
                try {
                    // 云端重置
                    const resetUrl = (location.hostname==='localhost'||location.hostname==='127.0.0.1')
                        ? 'http://localhost:5001/chat-294cc/us-central1/resetState'
                        : 'https://us-central1-chat-294cc.cloudfunctions.net/resetState';
                    await fetch(resetUrl, { method:'POST' });
                } catch {}
                // 本地界面同步清空
                pauseSimulation();
                initialize();
            });
            mobileResetBtn.addEventListener('click', () => {
                toggleMobileMenu();
                pauseSimulation();
                initialize();
            });
            // 关于按钮已禁用
            mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            
            // 点击模态框外部关闭
            // 关于模态框已移除
            
            // 存档/读档
            function getUserId(){
                try {
                    let id = localStorage.getItem('ai-civ-user-id');
                    if (!id) {
                        id = (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : `u_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                        localStorage.setItem('ai-civ-user-id', id);
                    }
                    return id;
                } catch { return 'u_default'; }
            }
            function getSnapKey(){ return `ai-civ-sim:${getUserId()}`; }
            function saveSnapshot() {
                try {
                    const snapshot = {
                        civilization,
                        day, year, totalDays,
                        aiEnabled, aiFrequency, mode, guidelines, autosaveEnabled
                    };
                    localStorage.setItem(getSnapKey(), JSON.stringify(snapshot));
                } catch {}
            }
            function loadSnapshot() {
                try {
                    const raw = localStorage.getItem(getSnapKey());
                    if (!raw) return false;
                    const snap = JSON.parse(raw);
                    if (!snap || !snap.civilization) return false;
                    civilization = snap.civilization;
                    day = snap.day || 0; year = snap.year || 0; totalDays = snap.totalDays || 0;
                    aiEnabled = !!snap.aiEnabled;
                    aiFrequency = snap.aiFrequency || 3;
                    mode = snap.mode || 'normal';
                    guidelines = snap.guidelines || '';
                    autosaveEnabled = snap.autosaveEnabled !== false;
                    // 同步控件
                    document.getElementById('ai-toggle-text').textContent = aiEnabled ? 'AI Evolution ON' : 'AI Evolution OFF';
                    document.getElementById('ai-frequency').value = String(aiFrequency);
                    document.getElementById('mode-select').value = mode;
                    document.getElementById('guidelines-input').value = guidelines;
                    document.getElementById('autosave-toggle').checked = autosaveEnabled;
                    updateUI();
                    return true;
                } catch {
                    return false;
                }
            }

            // 初始化模拟（每用户本地存档）
            if (!loadSnapshot()) {
                initialize();
            } else {
                // 隐藏加载状态（读档无需加载遮罩）
                loadingOverlay.classList.add('hidden');
            }
            // 确保视觉循环已启动
            startVisualLoop();

            // 默认自动开始并开启 AI 演化
            try {
                aiEnabled = true;
                const aiText = document.getElementById('ai-toggle-text');
                if (aiText) aiText.textContent = 'AI Evolution ON';
                const btn = document.getElementById('ai-toggle-btn');
                if (btn) { btn.classList.remove('bg-gray-700'); btn.classList.add('bg-success/20'); }
                startSimulation();
            } catch {}

            // 预初始化网格，便于逐行更新
            function ensureFieldGrids() {
                if (!localFieldCanvas || !Array.isArray(localFieldCanvas.grid) || localFieldCanvas.grid.length !== FIELD_CANVAS_ROWS) {
                    localFieldCanvas = { grid: new Array(FIELD_CANVAS_ROWS).fill('').map(() => ' '.repeat(FIELD_CANVAS_COLS)) };
                }
                if (!localEnemyFieldCanvas || !Array.isArray(localEnemyFieldCanvas.grid) || localEnemyFieldCanvas.grid.length !== FIELD_CANVAS_ROWS) {
                    localEnemyFieldCanvas = { grid: new Array(FIELD_CANVAS_ROWS).fill('').map(() => ' '.repeat(FIELD_CANVAS_COLS)) };
                }
                if (!Array.isArray(localInfluenceGrid) || localInfluenceGrid.length !== FIELD_CANVAS_ROWS) {
                    localInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
                }
                if (!Array.isArray(enemyInfluenceGrid) || enemyInfluenceGrid.length !== FIELD_CANVAS_ROWS) {
                    enemyInfluenceGrid = new Array(FIELD_CANVAS_ROWS).fill(null);
                }
            }

            function computeFieldRow(features, j, cols, rows, isEnemy) {
                const y = (j + 0.5) / rows * 100;
                let rowChars = '';
                const strengths = new Float32Array(cols);
                for (let i = 0; i < cols; i++) {
                    const x = (i + 0.5) / cols * 100;
                    let chInt = { settlement: 0, technology: 0, defense: 0, government: 0, conflict: 0, breakthrough: 0 };
                    for (const f of features) {
                        const seed = (f.id % 1000) / 1000;
                        const ampX = DRIFT_AMPLITUDE * (0.6 + seed * 0.8) * (f.isLarge ? 1.2 : 1.0);
                        const ampY = DRIFT_AMPLITUDE * (0.6 + (1 - seed) * 0.8) * (f.isLarge ? 1.2 : 1.0);
                        const fx = f.x + Math.sin(visualPhase * (isEnemy ? 1.25 : 1.3) + seed * 6.283) * ampX;
                        const fy = f.y + Math.cos(visualPhase * (isEnemy ? 1.18 : 1.1) + seed * 6.283) * ampY;
                        const dx = x - fx;
                        const dy = y - fy;
                        const d2 = dx*dx + dy*dy;
                        const type = (f.type in FIELD_SIGMA) ? f.type : 'settlement';
                        const sigma = (FIELD_SIGMA[type] || 9) * (f.isLarge ? 1.2 : 1.0);
                        const val = Math.exp(-d2 / (2 * sigma * sigma));
                        chInt[type] += val;
                    }
                    const shimmer = 1 + 0.08 * (isEnemy
                        ? Math.cos(visualPhase * 4.3 + i * 0.19 + j * 0.41)
                        : Math.sin(visualPhase * 4.0 + i * 0.21 + j * 0.37));
                    for (const k in chInt) { chInt[k] *= shimmer; }
                    let maxType = 'settlement'; let maxVal = -1;
                    for (const k in chInt) { if (chInt[k] > maxVal) { maxVal = chInt[k]; maxType = k; } }
                    strengths[i] = maxVal;
                    if (maxVal < 0.12) { rowChars += ' '; }
                    else {
                        const cs = FIELD_CHARSETS[maxType] || [' ', '.', '+', '#'];
                        const level = Math.max(0, Math.min(3, Math.floor(maxVal * 3.5)));
                        rowChars += cs[level];
                    }
                }
                return { rowChars, strengths };
            }

            function updateFieldCanvasStep() {
                ensureFieldGrids();
                const features = civilization.settlements || [];
                for (let n = 0; n < ROWS_PER_FRAME; n++) {
                    const j = rowCursorLocal % FIELD_CANVAS_ROWS;
                    const res = computeFieldRow(features, j, FIELD_CANVAS_COLS, FIELD_CANVAS_ROWS, false);
                    localFieldCanvas.grid[j] = res.rowChars;
                    localInfluenceGrid[j] = res.strengths;
                    rowCursorLocal++;
                }
            }

            function updateEnemyFieldCanvasStep() {
                ensureFieldGrids();
                const features = enemy.settlements || [];
                for (let n = 0; n < ROWS_PER_FRAME; n++) {
                    const j = rowCursorEnemy % FIELD_CANVAS_ROWS;
                    const res = computeFieldRow(features, j, FIELD_CANVAS_COLS, FIELD_CANVAS_ROWS, true);
                    localEnemyFieldCanvas.grid[j] = res.rowChars;
                    enemyInfluenceGrid[j] = res.strengths;
                    rowCursorEnemy++;
                }
            }

            // 持续视觉循环（requestAnimationFrame）
            function startVisualLoop() {
                if (rafId) { try { cancelAnimationFrame(rafId); } catch {} }
                ensureFieldGrids();
                const tick = () => {
                    visualPhase += 0.06;
                    updateFieldCanvasStep();
                    updateEnemyFieldCanvasStep();
                    frameParity ^= 1;
                    if (frameParity === 0) {
                        renderAsciiCanvasMerged();
                        renderEnemyAsciiCanvasMerged();
                    }
                    rafId = requestAnimationFrame(tick);
                };
                rafId = requestAnimationFrame(tick);
            }
            function stopVisualLoop() {
                if (rafId) { try { cancelAnimationFrame(rafId); } catch {} }
                rafId = null;
            }
        });
    </script>
</body>
</html>
